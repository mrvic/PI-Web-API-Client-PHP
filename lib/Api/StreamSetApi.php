<?php
/**
 * StreamSetApi
 * PHP version 5
 *
 * @category Class
 * @package  PIWebAPI\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * PI Web API 2017 Swagger Spec
 *
 * Swagger Spec file that describes PI Web API
 *
 * OpenAPI spec version: 1.9.0.235
 * Contact: techsupport@osisoft.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace PIWebAPI\Client\Api;

use \PIWebAPI\Client\ApiClient;
use \PIWebAPI\Client\ApiException;
use \PIWebAPI\Client\Configuration;
use \PIWebAPI\Client\ObjectSerializer;

/**
 * StreamSetApi Class Doc Comment
 *
 * @category Class
 * @package  PIWebAPI\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class StreamSetApi
{
    /**
     * API Client
     *
     * @var \PIWebAPI\Client\ApiClient instance of the ApiClient
     */
    protected $apiClient;

    /**
     * Constructor
     *
     * @param \PIWebAPI\Client\ApiClient|null $apiClient The api client to use
     */
    public function __construct(\PIWebAPI\Client\ApiClient $apiClient = null)
    {
        if ($apiClient === null) {
            $apiClient = new ApiClient();
            $apiClient->getConfig()->setHost('https://proghackuc2017.osisoft.com/piwebapi');
        }

        $this->apiClient = $apiClient;
    }

    /**
     * Get API client
     *
     * @return \PIWebAPI\Client\ApiClient get the API client
     */
    public function getApiClient()
    {
        return $this->apiClient;
    }

    /**
     * Set the API client
     *
     * @param \PIWebAPI\Client\ApiClient $apiClient set the API client
     *
     * @return StreamSetApi
     */
    public function setApiClient(\PIWebAPI\Client\ApiClient $apiClient)
    {
        $this->apiClient = $apiClient;
        return $this;
    }

    /**
     * Operation streamSetGetChannel
     *
     * Opens a channel that will send messages about any value changes for the attributes of an Element, Event Frame, or Attribute.
     *
     * @param string $web_id The ID of an Element, Event Frame or Attribute, which is the base element or parent of all the stream attributes. (required)
     * @param string $category_name Specify that included attributes must have this category. The default is no category filter. (optional)
     * @param bool $include_initial_values Specified if the channel should send a message with the current values of all the streams after the connection is opened. The default is &#39;false&#39;. (optional)
     * @param string $name_filter The name query string used for filtering attributes. The default is no filter. (optional)
     * @param bool $search_full_hierarchy Specifies if the search should include attributes nested further than the immediate attributes of the searchRoot. The default is &#39;false&#39;. (optional)
     * @param bool $show_excluded Specified if the search should include attributes with the Excluded property set. The default is &#39;false&#39;. (optional)
     * @param bool $show_hidden Specified if the search should include attributes with the Hidden property set. The default is &#39;false&#39;. (optional)
     * @param string $template_name Specify that included attributes must be members of this template. The default is no template filter. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return void
     */
    public function streamSetGetChannel($web_id, $category_name = null, $include_initial_values = null, $name_filter = null, $search_full_hierarchy = null, $show_excluded = null, $show_hidden = null, $template_name = null)
    {
        list($response) = $this->streamSetGetChannelWithHttpInfo($web_id, $category_name, $include_initial_values, $name_filter, $search_full_hierarchy, $show_excluded, $show_hidden, $template_name);
        return $response;
    }

    /**
     * Operation streamSetGetChannelWithHttpInfo
     *
     * Opens a channel that will send messages about any value changes for the attributes of an Element, Event Frame, or Attribute.
     *
     * @param string $web_id The ID of an Element, Event Frame or Attribute, which is the base element or parent of all the stream attributes. (required)
     * @param string $category_name Specify that included attributes must have this category. The default is no category filter. (optional)
     * @param bool $include_initial_values Specified if the channel should send a message with the current values of all the streams after the connection is opened. The default is &#39;false&#39;. (optional)
     * @param string $name_filter The name query string used for filtering attributes. The default is no filter. (optional)
     * @param bool $search_full_hierarchy Specifies if the search should include attributes nested further than the immediate attributes of the searchRoot. The default is &#39;false&#39;. (optional)
     * @param bool $show_excluded Specified if the search should include attributes with the Excluded property set. The default is &#39;false&#39;. (optional)
     * @param bool $show_hidden Specified if the search should include attributes with the Hidden property set. The default is &#39;false&#39;. (optional)
     * @param string $template_name Specify that included attributes must be members of this template. The default is no template filter. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamSetGetChannelWithHttpInfo($web_id, $category_name = null, $include_initial_values = null, $name_filter = null, $search_full_hierarchy = null, $show_excluded = null, $show_hidden = null, $template_name = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling streamSetGetChannel');
        }
        // parse inputs
        $resourcePath = "/streamsets/{webId}/channel";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($category_name !== null) {
            $queryParams['categoryName'] = $this->apiClient->getSerializer()->toQueryValue($category_name);
        }
        // query params
        if ($include_initial_values !== null) {
            $queryParams['includeInitialValues'] = $this->apiClient->getSerializer()->toQueryValue($include_initial_values);
        }
        // query params
        if ($name_filter !== null) {
            $queryParams['nameFilter'] = $this->apiClient->getSerializer()->toQueryValue($name_filter);
        }
        // query params
        if ($search_full_hierarchy !== null) {
            $queryParams['searchFullHierarchy'] = $this->apiClient->getSerializer()->toQueryValue($search_full_hierarchy);
        }
        // query params
        if ($show_excluded !== null) {
            $queryParams['showExcluded'] = $this->apiClient->getSerializer()->toQueryValue($show_excluded);
        }
        // query params
        if ($show_hidden !== null) {
            $queryParams['showHidden'] = $this->apiClient->getSerializer()->toQueryValue($show_hidden);
        }
        // query params
        if ($template_name !== null) {
            $queryParams['templateName'] = $this->apiClient->getSerializer()->toQueryValue($template_name);
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                null,
                '/streamsets/{webId}/channel'
            );

            return [null, $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 101:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsStreamValue', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation streamSetGetChannelAdHoc
     *
     * Opens a channel that will send messages about any value changes for the specified streams.
     *
     * @param string[] $web_id The ID of a stream.  Multiple streams may be specified with multiple instances of the parameter. (required)
     * @param bool $include_initial_values Specified if the channel should send a message with the current values of all the streams after the connection is opened. The default is &#39;false&#39;. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return void
     */
    public function streamSetGetChannelAdHoc($web_id, $include_initial_values = null)
    {
        list($response) = $this->streamSetGetChannelAdHocWithHttpInfo($web_id, $include_initial_values);
        return $response;
    }

    /**
     * Operation streamSetGetChannelAdHocWithHttpInfo
     *
     * Opens a channel that will send messages about any value changes for the specified streams.
     *
     * @param string[] $web_id The ID of a stream.  Multiple streams may be specified with multiple instances of the parameter. (required)
     * @param bool $include_initial_values Specified if the channel should send a message with the current values of all the streams after the connection is opened. The default is &#39;false&#39;. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamSetGetChannelAdHocWithHttpInfo($web_id, $include_initial_values = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling streamSetGetChannelAdHoc');
        }
        // parse inputs
        $resourcePath = "/streamsets/channel";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if (is_array($web_id)) {
            $web_id = $this->apiClient->getSerializer()->serializeCollection($web_id, 'multi', true);
        }
        if ($web_id !== null) {
            $queryParams['webId'] = $this->apiClient->getSerializer()->toQueryValue($web_id);
        }
        // query params
        if ($include_initial_values !== null) {
            $queryParams['includeInitialValues'] = $this->apiClient->getSerializer()->toQueryValue($include_initial_values);
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                null,
                '/streamsets/channel'
            );

            return [null, $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 101:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsStreamValue', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation streamSetGetEnd
     *
     * Returns End of stream values of the attributes for an Element, Event Frame or Attribute
     *
     * @param string $web_id The ID of an Element, Event Frame or Attribute, which is the base element or parent of all the stream attributes. (required)
     * @param string $category_name Specify that included attributes must have this category. The default is no category filter. (optional)
     * @param string $name_filter The name query string used for filtering attributes. The default is no filter. (optional)
     * @param bool $search_full_hierarchy Specifies if the search should include attributes nested further than the immediate attributes of the searchRoot. The default is &#39;false&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param bool $show_excluded Specified if the search should include attributes with the Excluded property set. The default is &#39;false&#39;. (optional)
     * @param bool $show_hidden Specified if the search should include attributes with the Hidden property set. The default is &#39;false&#39;. (optional)
     * @param string $template_name Specify that included attributes must be members of this template. The default is no template filter. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\ItemsStreamValue
     */
    public function streamSetGetEnd($web_id, $category_name = null, $name_filter = null, $search_full_hierarchy = null, $selected_fields = null, $show_excluded = null, $show_hidden = null, $template_name = null)
    {
        list($response) = $this->streamSetGetEndWithHttpInfo($web_id, $category_name, $name_filter, $search_full_hierarchy, $selected_fields, $show_excluded, $show_hidden, $template_name);
        return $response;
    }

    /**
     * Operation streamSetGetEndWithHttpInfo
     *
     * Returns End of stream values of the attributes for an Element, Event Frame or Attribute
     *
     * @param string $web_id The ID of an Element, Event Frame or Attribute, which is the base element or parent of all the stream attributes. (required)
     * @param string $category_name Specify that included attributes must have this category. The default is no category filter. (optional)
     * @param string $name_filter The name query string used for filtering attributes. The default is no filter. (optional)
     * @param bool $search_full_hierarchy Specifies if the search should include attributes nested further than the immediate attributes of the searchRoot. The default is &#39;false&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param bool $show_excluded Specified if the search should include attributes with the Excluded property set. The default is &#39;false&#39;. (optional)
     * @param bool $show_hidden Specified if the search should include attributes with the Hidden property set. The default is &#39;false&#39;. (optional)
     * @param string $template_name Specify that included attributes must be members of this template. The default is no template filter. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\ItemsStreamValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamSetGetEndWithHttpInfo($web_id, $category_name = null, $name_filter = null, $search_full_hierarchy = null, $selected_fields = null, $show_excluded = null, $show_hidden = null, $template_name = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling streamSetGetEnd');
        }
        // parse inputs
        $resourcePath = "/streamsets/{webId}/end";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($category_name !== null) {
            $queryParams['categoryName'] = $this->apiClient->getSerializer()->toQueryValue($category_name);
        }
        // query params
        if ($name_filter !== null) {
            $queryParams['nameFilter'] = $this->apiClient->getSerializer()->toQueryValue($name_filter);
        }
        // query params
        if ($search_full_hierarchy !== null) {
            $queryParams['searchFullHierarchy'] = $this->apiClient->getSerializer()->toQueryValue($search_full_hierarchy);
        }
        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // query params
        if ($show_excluded !== null) {
            $queryParams['showExcluded'] = $this->apiClient->getSerializer()->toQueryValue($show_excluded);
        }
        // query params
        if ($show_hidden !== null) {
            $queryParams['showHidden'] = $this->apiClient->getSerializer()->toQueryValue($show_hidden);
        }
        // query params
        if ($template_name !== null) {
            $queryParams['templateName'] = $this->apiClient->getSerializer()->toQueryValue($template_name);
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\ItemsStreamValue',
                '/streamsets/{webId}/end'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\ItemsStreamValue', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsStreamValue', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation streamSetGetEndAdHoc
     *
     * Returns End Of Stream values for attributes of the specified streams
     *
     * @param string[] $web_id The ID of a stream.  Multiple streams may be specified with multiple instances of the parameter. (required)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\ItemsStreamValues
     */
    public function streamSetGetEndAdHoc($web_id, $selected_fields = null)
    {
        list($response) = $this->streamSetGetEndAdHocWithHttpInfo($web_id, $selected_fields);
        return $response;
    }

    /**
     * Operation streamSetGetEndAdHocWithHttpInfo
     *
     * Returns End Of Stream values for attributes of the specified streams
     *
     * @param string[] $web_id The ID of a stream.  Multiple streams may be specified with multiple instances of the parameter. (required)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\ItemsStreamValues, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamSetGetEndAdHocWithHttpInfo($web_id, $selected_fields = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling streamSetGetEndAdHoc');
        }
        // parse inputs
        $resourcePath = "/streamsets/end";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if (is_array($web_id)) {
            $web_id = $this->apiClient->getSerializer()->serializeCollection($web_id, 'multi', true);
        }
        if ($web_id !== null) {
            $queryParams['webId'] = $this->apiClient->getSerializer()->toQueryValue($web_id);
        }
        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\ItemsStreamValues',
                '/streamsets/end'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\ItemsStreamValues', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsStreamValues', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation streamSetGetInterpolated
     *
     * Returns interpolated values of attributes for an element, event frame or attribute over the specified time range at the specified sampling interval.
     *
     * @param string $web_id The ID of an element, event frame or attribute, which is the base element or parent of all the stream attributes. (required)
     * @param string $category_name Specify that included attributes must have this category. The default is no category filter. (optional)
     * @param string $end_time An optional end time. The default is &#39;*&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s end time, or &#39;*&#39; if that is not set. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order. (optional)
     * @param string $filter_expression An optional string containing a filter expression. Expression variables are relative to the data point. Use &#39;.&#39; to reference the containing attribute. If the attribute does not support filtering, the filter will be ignored. The default is no filtering. (optional)
     * @param bool $include_filtered_values Specify &#39;true&#39; to indicate that values which fail the filter criteria are present in the returned data at the times where they occurred with a value set to a &#39;Filtered&#39; enumeration value with bad status. Repeated consecutive failures are omitted. (optional)
     * @param string $interval The sampling interval, in AFTimeSpan format. (optional)
     * @param string $name_filter The name query string used for filtering attributes. The default is no filter. (optional)
     * @param bool $search_full_hierarchy Specifies if the search should include attributes nested further than the immediate attributes of the searchRoot. The default is &#39;false&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param bool $show_excluded Specified if the search should include attributes with the Excluded property set. The default is &#39;false&#39;. (optional)
     * @param bool $show_hidden Specified if the search should include attributes with the Hidden property set. The default is &#39;false&#39;. (optional)
     * @param string $start_time An optional start time. The default is &#39;*-1d&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s start time, or &#39;*-1d&#39; if that is not set. (optional)
     * @param string $template_name Specify that included attributes must be members of this template. The default is no template filter. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\ItemsStreamValues
     */
    public function streamSetGetInterpolated($web_id, $category_name = null, $end_time = null, $filter_expression = null, $include_filtered_values = null, $interval = null, $name_filter = null, $search_full_hierarchy = null, $selected_fields = null, $show_excluded = null, $show_hidden = null, $start_time = null, $template_name = null, $time_zone = null)
    {
        list($response) = $this->streamSetGetInterpolatedWithHttpInfo($web_id, $category_name, $end_time, $filter_expression, $include_filtered_values, $interval, $name_filter, $search_full_hierarchy, $selected_fields, $show_excluded, $show_hidden, $start_time, $template_name, $time_zone);
        return $response;
    }

    /**
     * Operation streamSetGetInterpolatedWithHttpInfo
     *
     * Returns interpolated values of attributes for an element, event frame or attribute over the specified time range at the specified sampling interval.
     *
     * @param string $web_id The ID of an element, event frame or attribute, which is the base element or parent of all the stream attributes. (required)
     * @param string $category_name Specify that included attributes must have this category. The default is no category filter. (optional)
     * @param string $end_time An optional end time. The default is &#39;*&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s end time, or &#39;*&#39; if that is not set. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order. (optional)
     * @param string $filter_expression An optional string containing a filter expression. Expression variables are relative to the data point. Use &#39;.&#39; to reference the containing attribute. If the attribute does not support filtering, the filter will be ignored. The default is no filtering. (optional)
     * @param bool $include_filtered_values Specify &#39;true&#39; to indicate that values which fail the filter criteria are present in the returned data at the times where they occurred with a value set to a &#39;Filtered&#39; enumeration value with bad status. Repeated consecutive failures are omitted. (optional)
     * @param string $interval The sampling interval, in AFTimeSpan format. (optional)
     * @param string $name_filter The name query string used for filtering attributes. The default is no filter. (optional)
     * @param bool $search_full_hierarchy Specifies if the search should include attributes nested further than the immediate attributes of the searchRoot. The default is &#39;false&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param bool $show_excluded Specified if the search should include attributes with the Excluded property set. The default is &#39;false&#39;. (optional)
     * @param bool $show_hidden Specified if the search should include attributes with the Hidden property set. The default is &#39;false&#39;. (optional)
     * @param string $start_time An optional start time. The default is &#39;*-1d&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s start time, or &#39;*-1d&#39; if that is not set. (optional)
     * @param string $template_name Specify that included attributes must be members of this template. The default is no template filter. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\ItemsStreamValues, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamSetGetInterpolatedWithHttpInfo($web_id, $category_name = null, $end_time = null, $filter_expression = null, $include_filtered_values = null, $interval = null, $name_filter = null, $search_full_hierarchy = null, $selected_fields = null, $show_excluded = null, $show_hidden = null, $start_time = null, $template_name = null, $time_zone = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling streamSetGetInterpolated');
        }
        // parse inputs
        $resourcePath = "/streamsets/{webId}/interpolated";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($category_name !== null) {
            $queryParams['categoryName'] = $this->apiClient->getSerializer()->toQueryValue($category_name);
        }
        // query params
        if ($end_time !== null) {
            $queryParams['endTime'] = $this->apiClient->getSerializer()->toQueryValue($end_time);
        }
        // query params
        if ($filter_expression !== null) {
            $queryParams['filterExpression'] = $this->apiClient->getSerializer()->toQueryValue($filter_expression);
        }
        // query params
        if ($include_filtered_values !== null) {
            $queryParams['includeFilteredValues'] = $this->apiClient->getSerializer()->toQueryValue($include_filtered_values);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = $this->apiClient->getSerializer()->toQueryValue($interval);
        }
        // query params
        if ($name_filter !== null) {
            $queryParams['nameFilter'] = $this->apiClient->getSerializer()->toQueryValue($name_filter);
        }
        // query params
        if ($search_full_hierarchy !== null) {
            $queryParams['searchFullHierarchy'] = $this->apiClient->getSerializer()->toQueryValue($search_full_hierarchy);
        }
        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // query params
        if ($show_excluded !== null) {
            $queryParams['showExcluded'] = $this->apiClient->getSerializer()->toQueryValue($show_excluded);
        }
        // query params
        if ($show_hidden !== null) {
            $queryParams['showHidden'] = $this->apiClient->getSerializer()->toQueryValue($show_hidden);
        }
        // query params
        if ($start_time !== null) {
            $queryParams['startTime'] = $this->apiClient->getSerializer()->toQueryValue($start_time);
        }
        // query params
        if ($template_name !== null) {
            $queryParams['templateName'] = $this->apiClient->getSerializer()->toQueryValue($template_name);
        }
        // query params
        if ($time_zone !== null) {
            $queryParams['timeZone'] = $this->apiClient->getSerializer()->toQueryValue($time_zone);
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\ItemsStreamValues',
                '/streamsets/{webId}/interpolated'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\ItemsStreamValues', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsStreamValues', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation streamSetGetInterpolatedAdHoc
     *
     * Returns interpolated values of the specified streams over the specified time range at the specified sampling interval.
     *
     * @param string[] $web_id The ID of a stream. Multiple streams may be specified with multiple instances of the parameter. (required)
     * @param string $end_time An optional end time. The default is &#39;*&#39;. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order. (optional)
     * @param string $filter_expression An optional string containing a filter expression. Expression variables are relative to the data point. Use &#39;.&#39; to reference the containing attribute. If the attribute does not support filtering, the filter will be ignored. The default is no filtering. (optional)
     * @param bool $include_filtered_values Specify &#39;true&#39; to indicate that values which fail the filter criteria are present in the returned data at the times where they occurred with a value set to a &#39;Filtered&#39; enumeration value with bad status. Repeated consecutive failures are omitted. (optional)
     * @param string $interval The sampling interval, in AFTimeSpan format. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string $start_time An optional start time. The default is &#39;*-1d&#39;. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\ItemsStreamValues
     */
    public function streamSetGetInterpolatedAdHoc($web_id, $end_time = null, $filter_expression = null, $include_filtered_values = null, $interval = null, $selected_fields = null, $start_time = null, $time_zone = null)
    {
        list($response) = $this->streamSetGetInterpolatedAdHocWithHttpInfo($web_id, $end_time, $filter_expression, $include_filtered_values, $interval, $selected_fields, $start_time, $time_zone);
        return $response;
    }

    /**
     * Operation streamSetGetInterpolatedAdHocWithHttpInfo
     *
     * Returns interpolated values of the specified streams over the specified time range at the specified sampling interval.
     *
     * @param string[] $web_id The ID of a stream. Multiple streams may be specified with multiple instances of the parameter. (required)
     * @param string $end_time An optional end time. The default is &#39;*&#39;. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order. (optional)
     * @param string $filter_expression An optional string containing a filter expression. Expression variables are relative to the data point. Use &#39;.&#39; to reference the containing attribute. If the attribute does not support filtering, the filter will be ignored. The default is no filtering. (optional)
     * @param bool $include_filtered_values Specify &#39;true&#39; to indicate that values which fail the filter criteria are present in the returned data at the times where they occurred with a value set to a &#39;Filtered&#39; enumeration value with bad status. Repeated consecutive failures are omitted. (optional)
     * @param string $interval The sampling interval, in AFTimeSpan format. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string $start_time An optional start time. The default is &#39;*-1d&#39;. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\ItemsStreamValues, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamSetGetInterpolatedAdHocWithHttpInfo($web_id, $end_time = null, $filter_expression = null, $include_filtered_values = null, $interval = null, $selected_fields = null, $start_time = null, $time_zone = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling streamSetGetInterpolatedAdHoc');
        }
        // parse inputs
        $resourcePath = "/streamsets/interpolated";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if (is_array($web_id)) {
            $web_id = $this->apiClient->getSerializer()->serializeCollection($web_id, 'multi', true);
        }
        if ($web_id !== null) {
            $queryParams['webId'] = $this->apiClient->getSerializer()->toQueryValue($web_id);
        }
        // query params
        if ($end_time !== null) {
            $queryParams['endTime'] = $this->apiClient->getSerializer()->toQueryValue($end_time);
        }
        // query params
        if ($filter_expression !== null) {
            $queryParams['filterExpression'] = $this->apiClient->getSerializer()->toQueryValue($filter_expression);
        }
        // query params
        if ($include_filtered_values !== null) {
            $queryParams['includeFilteredValues'] = $this->apiClient->getSerializer()->toQueryValue($include_filtered_values);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = $this->apiClient->getSerializer()->toQueryValue($interval);
        }
        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // query params
        if ($start_time !== null) {
            $queryParams['startTime'] = $this->apiClient->getSerializer()->toQueryValue($start_time);
        }
        // query params
        if ($time_zone !== null) {
            $queryParams['timeZone'] = $this->apiClient->getSerializer()->toQueryValue($time_zone);
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\ItemsStreamValues',
                '/streamsets/interpolated'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\ItemsStreamValues', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsStreamValues', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation streamSetGetInterpolatedAtTimes
     *
     * Returns interpolated values of attributes for an element, event frame or attribute at the specified times.
     *
     * @param string $web_id The ID of an element, event frame or attribute, which is the base element or parent of all the stream attributes. (required)
     * @param string[] $time The timestamp at which to retrieve a interpolated value. Multiple timestamps may be specified with multiple instances of the parameter. (required)
     * @param string $category_name Specify that included attributes must have this category. The default is no category filter. (optional)
     * @param string $filter_expression An optional string containing a filter expression. Expression variables are relative to the data point. Use &#39;.&#39; to reference the containing attribute. If the attribute does not support filtering, the filter will be ignored. The default is no filtering. (optional)
     * @param bool $include_filtered_values Specify &#39;true&#39; to indicate that values which fail the filter criteria are present in the returned data at the times where they occurred with a value set to a &#39;Filtered&#39; enumeration value with bad status. Repeated consecutive failures are omitted. (optional)
     * @param string $name_filter The name query string used for filtering attributes. The default is no filter. (optional)
     * @param bool $search_full_hierarchy Specifies if the search should include attributes nested further than the immediate attributes of the searchRoot. The default is &#39;false&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param bool $show_excluded Specified if the search should include attributes with the Excluded property set. The default is &#39;false&#39;. (optional)
     * @param bool $show_hidden Specified if the search should include attributes with the Hidden property set. The default is &#39;false&#39;. (optional)
     * @param string $sort_order The order that the returned collection is sorted. The default is &#39;Ascending&#39;. (optional)
     * @param string $template_name Specify that included attributes must be members of this template. The default is no template filter. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\ItemsStreamValues
     */
    public function streamSetGetInterpolatedAtTimes($web_id, $time, $category_name = null, $filter_expression = null, $include_filtered_values = null, $name_filter = null, $search_full_hierarchy = null, $selected_fields = null, $show_excluded = null, $show_hidden = null, $sort_order = null, $template_name = null, $time_zone = null)
    {
        list($response) = $this->streamSetGetInterpolatedAtTimesWithHttpInfo($web_id, $time, $category_name, $filter_expression, $include_filtered_values, $name_filter, $search_full_hierarchy, $selected_fields, $show_excluded, $show_hidden, $sort_order, $template_name, $time_zone);
        return $response;
    }

    /**
     * Operation streamSetGetInterpolatedAtTimesWithHttpInfo
     *
     * Returns interpolated values of attributes for an element, event frame or attribute at the specified times.
     *
     * @param string $web_id The ID of an element, event frame or attribute, which is the base element or parent of all the stream attributes. (required)
     * @param string[] $time The timestamp at which to retrieve a interpolated value. Multiple timestamps may be specified with multiple instances of the parameter. (required)
     * @param string $category_name Specify that included attributes must have this category. The default is no category filter. (optional)
     * @param string $filter_expression An optional string containing a filter expression. Expression variables are relative to the data point. Use &#39;.&#39; to reference the containing attribute. If the attribute does not support filtering, the filter will be ignored. The default is no filtering. (optional)
     * @param bool $include_filtered_values Specify &#39;true&#39; to indicate that values which fail the filter criteria are present in the returned data at the times where they occurred with a value set to a &#39;Filtered&#39; enumeration value with bad status. Repeated consecutive failures are omitted. (optional)
     * @param string $name_filter The name query string used for filtering attributes. The default is no filter. (optional)
     * @param bool $search_full_hierarchy Specifies if the search should include attributes nested further than the immediate attributes of the searchRoot. The default is &#39;false&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param bool $show_excluded Specified if the search should include attributes with the Excluded property set. The default is &#39;false&#39;. (optional)
     * @param bool $show_hidden Specified if the search should include attributes with the Hidden property set. The default is &#39;false&#39;. (optional)
     * @param string $sort_order The order that the returned collection is sorted. The default is &#39;Ascending&#39;. (optional)
     * @param string $template_name Specify that included attributes must be members of this template. The default is no template filter. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\ItemsStreamValues, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamSetGetInterpolatedAtTimesWithHttpInfo($web_id, $time, $category_name = null, $filter_expression = null, $include_filtered_values = null, $name_filter = null, $search_full_hierarchy = null, $selected_fields = null, $show_excluded = null, $show_hidden = null, $sort_order = null, $template_name = null, $time_zone = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling streamSetGetInterpolatedAtTimes');
        }
        // verify the required parameter 'time' is set
        if ($time === null) {
            throw new \InvalidArgumentException('Missing the required parameter $time when calling streamSetGetInterpolatedAtTimes');
        }
        // parse inputs
        $resourcePath = "/streamsets/{webId}/interpolatedattimes";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if (is_array($time)) {
            $time = $this->apiClient->getSerializer()->serializeCollection($time, 'multi', true);
        }
        if ($time !== null) {
            $queryParams['time'] = $this->apiClient->getSerializer()->toQueryValue($time);
        }
        // query params
        if ($category_name !== null) {
            $queryParams['categoryName'] = $this->apiClient->getSerializer()->toQueryValue($category_name);
        }
        // query params
        if ($filter_expression !== null) {
            $queryParams['filterExpression'] = $this->apiClient->getSerializer()->toQueryValue($filter_expression);
        }
        // query params
        if ($include_filtered_values !== null) {
            $queryParams['includeFilteredValues'] = $this->apiClient->getSerializer()->toQueryValue($include_filtered_values);
        }
        // query params
        if ($name_filter !== null) {
            $queryParams['nameFilter'] = $this->apiClient->getSerializer()->toQueryValue($name_filter);
        }
        // query params
        if ($search_full_hierarchy !== null) {
            $queryParams['searchFullHierarchy'] = $this->apiClient->getSerializer()->toQueryValue($search_full_hierarchy);
        }
        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // query params
        if ($show_excluded !== null) {
            $queryParams['showExcluded'] = $this->apiClient->getSerializer()->toQueryValue($show_excluded);
        }
        // query params
        if ($show_hidden !== null) {
            $queryParams['showHidden'] = $this->apiClient->getSerializer()->toQueryValue($show_hidden);
        }
        // query params
        if ($sort_order !== null) {
            $queryParams['sortOrder'] = $this->apiClient->getSerializer()->toQueryValue($sort_order);
        }
        // query params
        if ($template_name !== null) {
            $queryParams['templateName'] = $this->apiClient->getSerializer()->toQueryValue($template_name);
        }
        // query params
        if ($time_zone !== null) {
            $queryParams['timeZone'] = $this->apiClient->getSerializer()->toQueryValue($time_zone);
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\ItemsStreamValues',
                '/streamsets/{webId}/interpolatedattimes'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\ItemsStreamValues', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsStreamValues', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 502:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation streamSetGetInterpolatedAtTimesAdHoc
     *
     * Returns interpolated values of the specified streams at the specified times.
     *
     * @param string[] $time The timestamp at which to retrieve a interpolated value. Multiple timestamps may be specified with multiple instances of the parameter. (required)
     * @param string[] $web_id The ID of a stream. Multiple streams may be specified with multiple instances of the parameter. (required)
     * @param string $filter_expression An optional string containing a filter expression. Expression variables are relative to the data point. Use &#39;.&#39; to reference the containing attribute. If the attribute does not support filtering, the filter will be ignored. The default is no filtering. (optional)
     * @param bool $include_filtered_values Specify &#39;true&#39; to indicate that values which fail the filter criteria are present in the returned data at the times where they occurred with a value set to a &#39;Filtered&#39; enumeration value with bad status. Repeated consecutive failures are omitted. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string $sort_order The order that the returned collection is sorted. The default is &#39;Ascending&#39;. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\ItemsStreamValues
     */
    public function streamSetGetInterpolatedAtTimesAdHoc($time, $web_id, $filter_expression = null, $include_filtered_values = null, $selected_fields = null, $sort_order = null, $time_zone = null)
    {
        list($response) = $this->streamSetGetInterpolatedAtTimesAdHocWithHttpInfo($time, $web_id, $filter_expression, $include_filtered_values, $selected_fields, $sort_order, $time_zone);
        return $response;
    }

    /**
     * Operation streamSetGetInterpolatedAtTimesAdHocWithHttpInfo
     *
     * Returns interpolated values of the specified streams at the specified times.
     *
     * @param string[] $time The timestamp at which to retrieve a interpolated value. Multiple timestamps may be specified with multiple instances of the parameter. (required)
     * @param string[] $web_id The ID of a stream. Multiple streams may be specified with multiple instances of the parameter. (required)
     * @param string $filter_expression An optional string containing a filter expression. Expression variables are relative to the data point. Use &#39;.&#39; to reference the containing attribute. If the attribute does not support filtering, the filter will be ignored. The default is no filtering. (optional)
     * @param bool $include_filtered_values Specify &#39;true&#39; to indicate that values which fail the filter criteria are present in the returned data at the times where they occurred with a value set to a &#39;Filtered&#39; enumeration value with bad status. Repeated consecutive failures are omitted. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string $sort_order The order that the returned collection is sorted. The default is &#39;Ascending&#39;. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\ItemsStreamValues, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamSetGetInterpolatedAtTimesAdHocWithHttpInfo($time, $web_id, $filter_expression = null, $include_filtered_values = null, $selected_fields = null, $sort_order = null, $time_zone = null)
    {
        // verify the required parameter 'time' is set
        if ($time === null) {
            throw new \InvalidArgumentException('Missing the required parameter $time when calling streamSetGetInterpolatedAtTimesAdHoc');
        }
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling streamSetGetInterpolatedAtTimesAdHoc');
        }
        // parse inputs
        $resourcePath = "/streamsets/interpolatedattimes";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if (is_array($time)) {
            $time = $this->apiClient->getSerializer()->serializeCollection($time, 'multi', true);
        }
        if ($time !== null) {
            $queryParams['time'] = $this->apiClient->getSerializer()->toQueryValue($time);
        }
        // query params
        if (is_array($web_id)) {
            $web_id = $this->apiClient->getSerializer()->serializeCollection($web_id, 'multi', true);
        }
        if ($web_id !== null) {
            $queryParams['webId'] = $this->apiClient->getSerializer()->toQueryValue($web_id);
        }
        // query params
        if ($filter_expression !== null) {
            $queryParams['filterExpression'] = $this->apiClient->getSerializer()->toQueryValue($filter_expression);
        }
        // query params
        if ($include_filtered_values !== null) {
            $queryParams['includeFilteredValues'] = $this->apiClient->getSerializer()->toQueryValue($include_filtered_values);
        }
        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // query params
        if ($sort_order !== null) {
            $queryParams['sortOrder'] = $this->apiClient->getSerializer()->toQueryValue($sort_order);
        }
        // query params
        if ($time_zone !== null) {
            $queryParams['timeZone'] = $this->apiClient->getSerializer()->toQueryValue($time_zone);
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\ItemsStreamValues',
                '/streamsets/interpolatedattimes'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\ItemsStreamValues', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsStreamValues', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 502:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation streamSetGetPlot
     *
     * Returns values of attributes for an element, event frame or attribute over the specified time range suitable for plotting over the number of intervals (typically represents pixels).
     *
     * @param string $web_id The ID of an element, event frame or attribute, which is the base element or parent of all the stream attributes. (required)
     * @param string $category_name Specify that included attributes must have this category. The default is no category filter. (optional)
     * @param string $end_time An optional end time. The default is &#39;*&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s end time, or &#39;*&#39; if that is not set. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order. (optional)
     * @param int $intervals The number of intervals to plot over. Typically, this would be the number of horizontal pixels in the trend. The default is &#39;24&#39;. For each interval, the data available is examined and significant values are returned. Each interval can produce up to 5 values if they are unique, the first value in the interval, the last value, the highest value, the lowest value and at most one exceptional point (bad status or digital state). (optional)
     * @param string $name_filter The name query string used for filtering attributes. The default is no filter. (optional)
     * @param bool $search_full_hierarchy Specifies if the search should include attributes nested further than the immediate attributes of the searchRoot. The default is &#39;false&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param bool $show_excluded Specified if the search should include attributes with the Excluded property set. The default is &#39;false&#39;. (optional)
     * @param bool $show_hidden Specified if the search should include attributes with the Hidden property set. The default is &#39;false&#39;. (optional)
     * @param string $start_time An optional start time. The default is &#39;*-1d&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s start time, or &#39;*-1d&#39; if that is not set. (optional)
     * @param string $template_name Specify that included attributes must be members of this template. The default is no template filter. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\ItemsStreamValues
     */
    public function streamSetGetPlot($web_id, $category_name = null, $end_time = null, $intervals = null, $name_filter = null, $search_full_hierarchy = null, $selected_fields = null, $show_excluded = null, $show_hidden = null, $start_time = null, $template_name = null, $time_zone = null)
    {
        list($response) = $this->streamSetGetPlotWithHttpInfo($web_id, $category_name, $end_time, $intervals, $name_filter, $search_full_hierarchy, $selected_fields, $show_excluded, $show_hidden, $start_time, $template_name, $time_zone);
        return $response;
    }

    /**
     * Operation streamSetGetPlotWithHttpInfo
     *
     * Returns values of attributes for an element, event frame or attribute over the specified time range suitable for plotting over the number of intervals (typically represents pixels).
     *
     * @param string $web_id The ID of an element, event frame or attribute, which is the base element or parent of all the stream attributes. (required)
     * @param string $category_name Specify that included attributes must have this category. The default is no category filter. (optional)
     * @param string $end_time An optional end time. The default is &#39;*&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s end time, or &#39;*&#39; if that is not set. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order. (optional)
     * @param int $intervals The number of intervals to plot over. Typically, this would be the number of horizontal pixels in the trend. The default is &#39;24&#39;. For each interval, the data available is examined and significant values are returned. Each interval can produce up to 5 values if they are unique, the first value in the interval, the last value, the highest value, the lowest value and at most one exceptional point (bad status or digital state). (optional)
     * @param string $name_filter The name query string used for filtering attributes. The default is no filter. (optional)
     * @param bool $search_full_hierarchy Specifies if the search should include attributes nested further than the immediate attributes of the searchRoot. The default is &#39;false&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param bool $show_excluded Specified if the search should include attributes with the Excluded property set. The default is &#39;false&#39;. (optional)
     * @param bool $show_hidden Specified if the search should include attributes with the Hidden property set. The default is &#39;false&#39;. (optional)
     * @param string $start_time An optional start time. The default is &#39;*-1d&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s start time, or &#39;*-1d&#39; if that is not set. (optional)
     * @param string $template_name Specify that included attributes must be members of this template. The default is no template filter. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\ItemsStreamValues, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamSetGetPlotWithHttpInfo($web_id, $category_name = null, $end_time = null, $intervals = null, $name_filter = null, $search_full_hierarchy = null, $selected_fields = null, $show_excluded = null, $show_hidden = null, $start_time = null, $template_name = null, $time_zone = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling streamSetGetPlot');
        }
        // parse inputs
        $resourcePath = "/streamsets/{webId}/plot";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($category_name !== null) {
            $queryParams['categoryName'] = $this->apiClient->getSerializer()->toQueryValue($category_name);
        }
        // query params
        if ($end_time !== null) {
            $queryParams['endTime'] = $this->apiClient->getSerializer()->toQueryValue($end_time);
        }
        // query params
        if ($intervals !== null) {
            $queryParams['intervals'] = $this->apiClient->getSerializer()->toQueryValue($intervals);
        }
        // query params
        if ($name_filter !== null) {
            $queryParams['nameFilter'] = $this->apiClient->getSerializer()->toQueryValue($name_filter);
        }
        // query params
        if ($search_full_hierarchy !== null) {
            $queryParams['searchFullHierarchy'] = $this->apiClient->getSerializer()->toQueryValue($search_full_hierarchy);
        }
        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // query params
        if ($show_excluded !== null) {
            $queryParams['showExcluded'] = $this->apiClient->getSerializer()->toQueryValue($show_excluded);
        }
        // query params
        if ($show_hidden !== null) {
            $queryParams['showHidden'] = $this->apiClient->getSerializer()->toQueryValue($show_hidden);
        }
        // query params
        if ($start_time !== null) {
            $queryParams['startTime'] = $this->apiClient->getSerializer()->toQueryValue($start_time);
        }
        // query params
        if ($template_name !== null) {
            $queryParams['templateName'] = $this->apiClient->getSerializer()->toQueryValue($template_name);
        }
        // query params
        if ($time_zone !== null) {
            $queryParams['timeZone'] = $this->apiClient->getSerializer()->toQueryValue($time_zone);
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\ItemsStreamValues',
                '/streamsets/{webId}/plot'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\ItemsStreamValues', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsStreamValues', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation streamSetGetPlotAdHoc
     *
     * Returns values of attributes for the specified streams over the specified time range suitable for plotting over the number of intervals (typically represents pixels).
     *
     * @param string[] $web_id The ID of a stream.  Multiple streams may be specified with multiple instances of the parameter. (required)
     * @param string $end_time An optional end time. The default is &#39;*&#39;. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order. (optional)
     * @param int $intervals The number of intervals to plot over. Typically, this would be the number of horizontal pixels in the trend. The default is &#39;24&#39;. For each interval, the data available is examined and significant values are returned. Each interval can produce up to 5 values if they are unique, the first value in the interval, the last value, the highest value, the lowest value and at most one exceptional point (bad status or digital state). (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string $start_time An optional start time. The default is &#39;*-1d&#39;. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\ItemsStreamValues
     */
    public function streamSetGetPlotAdHoc($web_id, $end_time = null, $intervals = null, $selected_fields = null, $start_time = null, $time_zone = null)
    {
        list($response) = $this->streamSetGetPlotAdHocWithHttpInfo($web_id, $end_time, $intervals, $selected_fields, $start_time, $time_zone);
        return $response;
    }

    /**
     * Operation streamSetGetPlotAdHocWithHttpInfo
     *
     * Returns values of attributes for the specified streams over the specified time range suitable for plotting over the number of intervals (typically represents pixels).
     *
     * @param string[] $web_id The ID of a stream.  Multiple streams may be specified with multiple instances of the parameter. (required)
     * @param string $end_time An optional end time. The default is &#39;*&#39;. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order. (optional)
     * @param int $intervals The number of intervals to plot over. Typically, this would be the number of horizontal pixels in the trend. The default is &#39;24&#39;. For each interval, the data available is examined and significant values are returned. Each interval can produce up to 5 values if they are unique, the first value in the interval, the last value, the highest value, the lowest value and at most one exceptional point (bad status or digital state). (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string $start_time An optional start time. The default is &#39;*-1d&#39;. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\ItemsStreamValues, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamSetGetPlotAdHocWithHttpInfo($web_id, $end_time = null, $intervals = null, $selected_fields = null, $start_time = null, $time_zone = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling streamSetGetPlotAdHoc');
        }
        // parse inputs
        $resourcePath = "/streamsets/plot";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if (is_array($web_id)) {
            $web_id = $this->apiClient->getSerializer()->serializeCollection($web_id, 'multi', true);
        }
        if ($web_id !== null) {
            $queryParams['webId'] = $this->apiClient->getSerializer()->toQueryValue($web_id);
        }
        // query params
        if ($end_time !== null) {
            $queryParams['endTime'] = $this->apiClient->getSerializer()->toQueryValue($end_time);
        }
        // query params
        if ($intervals !== null) {
            $queryParams['intervals'] = $this->apiClient->getSerializer()->toQueryValue($intervals);
        }
        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // query params
        if ($start_time !== null) {
            $queryParams['startTime'] = $this->apiClient->getSerializer()->toQueryValue($start_time);
        }
        // query params
        if ($time_zone !== null) {
            $queryParams['timeZone'] = $this->apiClient->getSerializer()->toQueryValue($time_zone);
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\ItemsStreamValues',
                '/streamsets/plot'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\ItemsStreamValues', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsStreamValues', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation streamSetGetRecorded
     *
     * Returns recorded values of the attributes for an element, event frame, or attribute.
     *
     * @param string $web_id The ID of an element, event frame or attribute, which is the base element or parent of all the stream attributes. (required)
     * @param string $boundary_type An optional value that determines how the times and values of the returned end points are determined. The default is &#39;Inside&#39;. (optional)
     * @param string $category_name Specify that included attributes must have this category. The default is no category filter. (optional)
     * @param string $end_time An optional end time. The default is &#39;*&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s end time, or &#39;*&#39; if that is not set. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order. (optional)
     * @param string $filter_expression An optional string containing a filter expression. Expression variables are relative to the data point. Use &#39;.&#39; to reference the containing attribute. The default is no filtering. (optional)
     * @param bool $include_filtered_values Specify &#39;true&#39; to indicate that values which fail the filter criteria are present in the returned data at the times where they occurred with a value set to a &#39;Filtered&#39; enumeration value with bad status. Repeated consecutive failures are omitted. (optional)
     * @param int $max_count The maximum number of values to be returned. The default is 1000. (optional)
     * @param string $name_filter The name query string used for filtering attributes. The default is no filter. (optional)
     * @param bool $search_full_hierarchy Specifies if the search should include attributes nested further than the immediate attributes of the searchRoot. The default is &#39;false&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param bool $show_excluded Specified if the search should include attributes with the Excluded property set. The default is &#39;false&#39;. (optional)
     * @param bool $show_hidden Specified if the search should include attributes with the Hidden property set. The default is &#39;false&#39;. (optional)
     * @param string $start_time An optional start time. The default is &#39;*-1d&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s start time, or &#39;*-1d&#39; if that is not set. (optional)
     * @param string $template_name Specify that included attributes must be members of this template. The default is no template filter. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\ItemsStreamValues
     */
    public function streamSetGetRecorded($web_id, $boundary_type = null, $category_name = null, $end_time = null, $filter_expression = null, $include_filtered_values = null, $max_count = null, $name_filter = null, $search_full_hierarchy = null, $selected_fields = null, $show_excluded = null, $show_hidden = null, $start_time = null, $template_name = null, $time_zone = null)
    {
        list($response) = $this->streamSetGetRecordedWithHttpInfo($web_id, $boundary_type, $category_name, $end_time, $filter_expression, $include_filtered_values, $max_count, $name_filter, $search_full_hierarchy, $selected_fields, $show_excluded, $show_hidden, $start_time, $template_name, $time_zone);
        return $response;
    }

    /**
     * Operation streamSetGetRecordedWithHttpInfo
     *
     * Returns recorded values of the attributes for an element, event frame, or attribute.
     *
     * @param string $web_id The ID of an element, event frame or attribute, which is the base element or parent of all the stream attributes. (required)
     * @param string $boundary_type An optional value that determines how the times and values of the returned end points are determined. The default is &#39;Inside&#39;. (optional)
     * @param string $category_name Specify that included attributes must have this category. The default is no category filter. (optional)
     * @param string $end_time An optional end time. The default is &#39;*&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s end time, or &#39;*&#39; if that is not set. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order. (optional)
     * @param string $filter_expression An optional string containing a filter expression. Expression variables are relative to the data point. Use &#39;.&#39; to reference the containing attribute. The default is no filtering. (optional)
     * @param bool $include_filtered_values Specify &#39;true&#39; to indicate that values which fail the filter criteria are present in the returned data at the times where they occurred with a value set to a &#39;Filtered&#39; enumeration value with bad status. Repeated consecutive failures are omitted. (optional)
     * @param int $max_count The maximum number of values to be returned. The default is 1000. (optional)
     * @param string $name_filter The name query string used for filtering attributes. The default is no filter. (optional)
     * @param bool $search_full_hierarchy Specifies if the search should include attributes nested further than the immediate attributes of the searchRoot. The default is &#39;false&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param bool $show_excluded Specified if the search should include attributes with the Excluded property set. The default is &#39;false&#39;. (optional)
     * @param bool $show_hidden Specified if the search should include attributes with the Hidden property set. The default is &#39;false&#39;. (optional)
     * @param string $start_time An optional start time. The default is &#39;*-1d&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s start time, or &#39;*-1d&#39; if that is not set. (optional)
     * @param string $template_name Specify that included attributes must be members of this template. The default is no template filter. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\ItemsStreamValues, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamSetGetRecordedWithHttpInfo($web_id, $boundary_type = null, $category_name = null, $end_time = null, $filter_expression = null, $include_filtered_values = null, $max_count = null, $name_filter = null, $search_full_hierarchy = null, $selected_fields = null, $show_excluded = null, $show_hidden = null, $start_time = null, $template_name = null, $time_zone = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling streamSetGetRecorded');
        }
        // parse inputs
        $resourcePath = "/streamsets/{webId}/recorded";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($boundary_type !== null) {
            $queryParams['boundaryType'] = $this->apiClient->getSerializer()->toQueryValue($boundary_type);
        }
        // query params
        if ($category_name !== null) {
            $queryParams['categoryName'] = $this->apiClient->getSerializer()->toQueryValue($category_name);
        }
        // query params
        if ($end_time !== null) {
            $queryParams['endTime'] = $this->apiClient->getSerializer()->toQueryValue($end_time);
        }
        // query params
        if ($filter_expression !== null) {
            $queryParams['filterExpression'] = $this->apiClient->getSerializer()->toQueryValue($filter_expression);
        }
        // query params
        if ($include_filtered_values !== null) {
            $queryParams['includeFilteredValues'] = $this->apiClient->getSerializer()->toQueryValue($include_filtered_values);
        }
        // query params
        if ($max_count !== null) {
            $queryParams['maxCount'] = $this->apiClient->getSerializer()->toQueryValue($max_count);
        }
        // query params
        if ($name_filter !== null) {
            $queryParams['nameFilter'] = $this->apiClient->getSerializer()->toQueryValue($name_filter);
        }
        // query params
        if ($search_full_hierarchy !== null) {
            $queryParams['searchFullHierarchy'] = $this->apiClient->getSerializer()->toQueryValue($search_full_hierarchy);
        }
        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // query params
        if ($show_excluded !== null) {
            $queryParams['showExcluded'] = $this->apiClient->getSerializer()->toQueryValue($show_excluded);
        }
        // query params
        if ($show_hidden !== null) {
            $queryParams['showHidden'] = $this->apiClient->getSerializer()->toQueryValue($show_hidden);
        }
        // query params
        if ($start_time !== null) {
            $queryParams['startTime'] = $this->apiClient->getSerializer()->toQueryValue($start_time);
        }
        // query params
        if ($template_name !== null) {
            $queryParams['templateName'] = $this->apiClient->getSerializer()->toQueryValue($template_name);
        }
        // query params
        if ($time_zone !== null) {
            $queryParams['timeZone'] = $this->apiClient->getSerializer()->toQueryValue($time_zone);
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\ItemsStreamValues',
                '/streamsets/{webId}/recorded'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\ItemsStreamValues', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsStreamValues', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation streamSetGetRecordedAdHoc
     *
     * Returns recorded values of the specified streams.
     *
     * @param string[] $web_id The ID of a stream.  Multiple streams may be specified with multiple instances of the parameter. (required)
     * @param string $boundary_type An optional value that determines how the times and values of the returned end points are determined. The default is &#39;Inside&#39;. (optional)
     * @param string $end_time An optional end time. The default is &#39;*&#39;. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order. (optional)
     * @param string $filter_expression An optional string containing a filter expression. Expression variables are relative to the data point. Use &#39;.&#39; to reference the containing attribute. The default is no filtering. (optional)
     * @param bool $include_filtered_values Specify &#39;true&#39; to indicate that values which fail the filter criteria are present in the returned data at the times where they occurred with a value set to a &#39;Filtered&#39; enumeration value with bad status. Repeated consecutive failures are omitted. (optional)
     * @param int $max_count The maximum number of values to be returned. The default is 1000. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string $start_time An optional start time. The default is &#39;*-1d&#39;. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\ItemsStreamValues
     */
    public function streamSetGetRecordedAdHoc($web_id, $boundary_type = null, $end_time = null, $filter_expression = null, $include_filtered_values = null, $max_count = null, $selected_fields = null, $start_time = null, $time_zone = null)
    {
        list($response) = $this->streamSetGetRecordedAdHocWithHttpInfo($web_id, $boundary_type, $end_time, $filter_expression, $include_filtered_values, $max_count, $selected_fields, $start_time, $time_zone);
        return $response;
    }

    /**
     * Operation streamSetGetRecordedAdHocWithHttpInfo
     *
     * Returns recorded values of the specified streams.
     *
     * @param string[] $web_id The ID of a stream.  Multiple streams may be specified with multiple instances of the parameter. (required)
     * @param string $boundary_type An optional value that determines how the times and values of the returned end points are determined. The default is &#39;Inside&#39;. (optional)
     * @param string $end_time An optional end time. The default is &#39;*&#39;. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order. (optional)
     * @param string $filter_expression An optional string containing a filter expression. Expression variables are relative to the data point. Use &#39;.&#39; to reference the containing attribute. The default is no filtering. (optional)
     * @param bool $include_filtered_values Specify &#39;true&#39; to indicate that values which fail the filter criteria are present in the returned data at the times where they occurred with a value set to a &#39;Filtered&#39; enumeration value with bad status. Repeated consecutive failures are omitted. (optional)
     * @param int $max_count The maximum number of values to be returned. The default is 1000. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string $start_time An optional start time. The default is &#39;*-1d&#39;. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\ItemsStreamValues, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamSetGetRecordedAdHocWithHttpInfo($web_id, $boundary_type = null, $end_time = null, $filter_expression = null, $include_filtered_values = null, $max_count = null, $selected_fields = null, $start_time = null, $time_zone = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling streamSetGetRecordedAdHoc');
        }
        // parse inputs
        $resourcePath = "/streamsets/recorded";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if (is_array($web_id)) {
            $web_id = $this->apiClient->getSerializer()->serializeCollection($web_id, 'multi', true);
        }
        if ($web_id !== null) {
            $queryParams['webId'] = $this->apiClient->getSerializer()->toQueryValue($web_id);
        }
        // query params
        if ($boundary_type !== null) {
            $queryParams['boundaryType'] = $this->apiClient->getSerializer()->toQueryValue($boundary_type);
        }
        // query params
        if ($end_time !== null) {
            $queryParams['endTime'] = $this->apiClient->getSerializer()->toQueryValue($end_time);
        }
        // query params
        if ($filter_expression !== null) {
            $queryParams['filterExpression'] = $this->apiClient->getSerializer()->toQueryValue($filter_expression);
        }
        // query params
        if ($include_filtered_values !== null) {
            $queryParams['includeFilteredValues'] = $this->apiClient->getSerializer()->toQueryValue($include_filtered_values);
        }
        // query params
        if ($max_count !== null) {
            $queryParams['maxCount'] = $this->apiClient->getSerializer()->toQueryValue($max_count);
        }
        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // query params
        if ($start_time !== null) {
            $queryParams['startTime'] = $this->apiClient->getSerializer()->toQueryValue($start_time);
        }
        // query params
        if ($time_zone !== null) {
            $queryParams['timeZone'] = $this->apiClient->getSerializer()->toQueryValue($time_zone);
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\ItemsStreamValues',
                '/streamsets/recorded'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\ItemsStreamValues', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsStreamValues', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation streamSetGetRecordedAtTime
     *
     * Returns recorded values of the attributes for an element, event frame, or attribute.
     *
     * @param string $web_id The ID of an element, event frame or attribute, which is the base element or parent of all the stream attributes. (required)
     * @param string $time The timestamp at which the values are desired. (required)
     * @param string $category_name Specify that included attributes must have this category. The default is no category filter. (optional)
     * @param string $name_filter The name query string used for filtering attributes. The default is no filter. (optional)
     * @param string $retrieval_mode An optional value that determines the values to return when values don&#39;t exist at the exact time specified. The default is &#39;Auto&#39;. (optional)
     * @param bool $search_full_hierarchy Specifies if the search should include attributes nested further than the immediate attributes of the searchRoot. The default is &#39;false&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param bool $show_excluded Specified if the search should include attributes with the Excluded property set. The default is &#39;false&#39;. (optional)
     * @param bool $show_hidden Specified if the search should include attributes with the Hidden property set. The default is &#39;false&#39;. (optional)
     * @param string $template_name Specify that included attributes must be members of this template. The default is no template filter. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\ItemsStreamValues
     */
    public function streamSetGetRecordedAtTime($web_id, $time, $category_name = null, $name_filter = null, $retrieval_mode = null, $search_full_hierarchy = null, $selected_fields = null, $show_excluded = null, $show_hidden = null, $template_name = null, $time_zone = null)
    {
        list($response) = $this->streamSetGetRecordedAtTimeWithHttpInfo($web_id, $time, $category_name, $name_filter, $retrieval_mode, $search_full_hierarchy, $selected_fields, $show_excluded, $show_hidden, $template_name, $time_zone);
        return $response;
    }

    /**
     * Operation streamSetGetRecordedAtTimeWithHttpInfo
     *
     * Returns recorded values of the attributes for an element, event frame, or attribute.
     *
     * @param string $web_id The ID of an element, event frame or attribute, which is the base element or parent of all the stream attributes. (required)
     * @param string $time The timestamp at which the values are desired. (required)
     * @param string $category_name Specify that included attributes must have this category. The default is no category filter. (optional)
     * @param string $name_filter The name query string used for filtering attributes. The default is no filter. (optional)
     * @param string $retrieval_mode An optional value that determines the values to return when values don&#39;t exist at the exact time specified. The default is &#39;Auto&#39;. (optional)
     * @param bool $search_full_hierarchy Specifies if the search should include attributes nested further than the immediate attributes of the searchRoot. The default is &#39;false&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param bool $show_excluded Specified if the search should include attributes with the Excluded property set. The default is &#39;false&#39;. (optional)
     * @param bool $show_hidden Specified if the search should include attributes with the Hidden property set. The default is &#39;false&#39;. (optional)
     * @param string $template_name Specify that included attributes must be members of this template. The default is no template filter. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\ItemsStreamValues, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamSetGetRecordedAtTimeWithHttpInfo($web_id, $time, $category_name = null, $name_filter = null, $retrieval_mode = null, $search_full_hierarchy = null, $selected_fields = null, $show_excluded = null, $show_hidden = null, $template_name = null, $time_zone = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling streamSetGetRecordedAtTime');
        }
        // verify the required parameter 'time' is set
        if ($time === null) {
            throw new \InvalidArgumentException('Missing the required parameter $time when calling streamSetGetRecordedAtTime');
        }
        // parse inputs
        $resourcePath = "/streamsets/{webId}/recordedattime";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($time !== null) {
            $queryParams['time'] = $this->apiClient->getSerializer()->toQueryValue($time);
        }
        // query params
        if ($category_name !== null) {
            $queryParams['categoryName'] = $this->apiClient->getSerializer()->toQueryValue($category_name);
        }
        // query params
        if ($name_filter !== null) {
            $queryParams['nameFilter'] = $this->apiClient->getSerializer()->toQueryValue($name_filter);
        }
        // query params
        if ($retrieval_mode !== null) {
            $queryParams['retrievalMode'] = $this->apiClient->getSerializer()->toQueryValue($retrieval_mode);
        }
        // query params
        if ($search_full_hierarchy !== null) {
            $queryParams['searchFullHierarchy'] = $this->apiClient->getSerializer()->toQueryValue($search_full_hierarchy);
        }
        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // query params
        if ($show_excluded !== null) {
            $queryParams['showExcluded'] = $this->apiClient->getSerializer()->toQueryValue($show_excluded);
        }
        // query params
        if ($show_hidden !== null) {
            $queryParams['showHidden'] = $this->apiClient->getSerializer()->toQueryValue($show_hidden);
        }
        // query params
        if ($template_name !== null) {
            $queryParams['templateName'] = $this->apiClient->getSerializer()->toQueryValue($template_name);
        }
        // query params
        if ($time_zone !== null) {
            $queryParams['timeZone'] = $this->apiClient->getSerializer()->toQueryValue($time_zone);
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\ItemsStreamValues',
                '/streamsets/{webId}/recordedattime'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\ItemsStreamValues', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsStreamValues', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation streamSetGetRecordedAtTimeAdHoc
     *
     * Returns recorded values based on the passed time and retrieval mode.
     *
     * @param string $time The timestamp at which the values are desired. (required)
     * @param string[] $web_id The ID of a stream.  Multiple streams may be specified with multiple instances of the parameter. (required)
     * @param string $retrieval_mode An optional value that determines the values to return when values don&#39;t exist at the exact time specified. The default is &#39;Auto&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\ItemsStreamValue
     */
    public function streamSetGetRecordedAtTimeAdHoc($time, $web_id, $retrieval_mode = null, $selected_fields = null, $time_zone = null)
    {
        list($response) = $this->streamSetGetRecordedAtTimeAdHocWithHttpInfo($time, $web_id, $retrieval_mode, $selected_fields, $time_zone);
        return $response;
    }

    /**
     * Operation streamSetGetRecordedAtTimeAdHocWithHttpInfo
     *
     * Returns recorded values based on the passed time and retrieval mode.
     *
     * @param string $time The timestamp at which the values are desired. (required)
     * @param string[] $web_id The ID of a stream.  Multiple streams may be specified with multiple instances of the parameter. (required)
     * @param string $retrieval_mode An optional value that determines the values to return when values don&#39;t exist at the exact time specified. The default is &#39;Auto&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\ItemsStreamValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamSetGetRecordedAtTimeAdHocWithHttpInfo($time, $web_id, $retrieval_mode = null, $selected_fields = null, $time_zone = null)
    {
        // verify the required parameter 'time' is set
        if ($time === null) {
            throw new \InvalidArgumentException('Missing the required parameter $time when calling streamSetGetRecordedAtTimeAdHoc');
        }
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling streamSetGetRecordedAtTimeAdHoc');
        }
        // parse inputs
        $resourcePath = "/streamsets/recordedattime";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($time !== null) {
            $queryParams['time'] = $this->apiClient->getSerializer()->toQueryValue($time);
        }
        // query params
        if (is_array($web_id)) {
            $web_id = $this->apiClient->getSerializer()->serializeCollection($web_id, 'multi', true);
        }
        if ($web_id !== null) {
            $queryParams['webId'] = $this->apiClient->getSerializer()->toQueryValue($web_id);
        }
        // query params
        if ($retrieval_mode !== null) {
            $queryParams['retrievalMode'] = $this->apiClient->getSerializer()->toQueryValue($retrieval_mode);
        }
        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // query params
        if ($time_zone !== null) {
            $queryParams['timeZone'] = $this->apiClient->getSerializer()->toQueryValue($time_zone);
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\ItemsStreamValue',
                '/streamsets/recordedattime'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\ItemsStreamValue', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsStreamValue', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation streamSetGetRecordedAtTimes
     *
     * Returns recorded values of attributes for an element, event frame or attribute at the specified times.
     *
     * @param string $web_id The ID of an element, event frame or attribute, which is the base element or parent of all the stream attributes. (required)
     * @param string[] $time The timestamp at which to retrieve a recorded value. Multiple timestamps may be specified with multiple instances of the parameter. (required)
     * @param string $category_name Specify that included attributes must have this category. The default is no category filter. (optional)
     * @param string $name_filter The name query string used for filtering attributes. The default is no filter. (optional)
     * @param string $retrieval_mode An optional value that determines the values to return when values don&#39;t exist at the exact time specified. The default is &#39;Auto&#39;. (optional)
     * @param bool $search_full_hierarchy Specifies if the search should include attributes nested further than the immediate attributes of the searchRoot. The default is &#39;false&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param bool $show_excluded Specified if the search should include attributes with the Excluded property set. The default is &#39;false&#39;. (optional)
     * @param bool $show_hidden Specified if the search should include attributes with the Hidden property set. The default is &#39;false&#39;. (optional)
     * @param string $sort_order The order that the returned collection is sorted. The default is &#39;Ascending&#39;. (optional)
     * @param string $template_name Specify that included attributes must be members of this template. The default is no template filter. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\ItemsStreamValues
     */
    public function streamSetGetRecordedAtTimes($web_id, $time, $category_name = null, $name_filter = null, $retrieval_mode = null, $search_full_hierarchy = null, $selected_fields = null, $show_excluded = null, $show_hidden = null, $sort_order = null, $template_name = null, $time_zone = null)
    {
        list($response) = $this->streamSetGetRecordedAtTimesWithHttpInfo($web_id, $time, $category_name, $name_filter, $retrieval_mode, $search_full_hierarchy, $selected_fields, $show_excluded, $show_hidden, $sort_order, $template_name, $time_zone);
        return $response;
    }

    /**
     * Operation streamSetGetRecordedAtTimesWithHttpInfo
     *
     * Returns recorded values of attributes for an element, event frame or attribute at the specified times.
     *
     * @param string $web_id The ID of an element, event frame or attribute, which is the base element or parent of all the stream attributes. (required)
     * @param string[] $time The timestamp at which to retrieve a recorded value. Multiple timestamps may be specified with multiple instances of the parameter. (required)
     * @param string $category_name Specify that included attributes must have this category. The default is no category filter. (optional)
     * @param string $name_filter The name query string used for filtering attributes. The default is no filter. (optional)
     * @param string $retrieval_mode An optional value that determines the values to return when values don&#39;t exist at the exact time specified. The default is &#39;Auto&#39;. (optional)
     * @param bool $search_full_hierarchy Specifies if the search should include attributes nested further than the immediate attributes of the searchRoot. The default is &#39;false&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param bool $show_excluded Specified if the search should include attributes with the Excluded property set. The default is &#39;false&#39;. (optional)
     * @param bool $show_hidden Specified if the search should include attributes with the Hidden property set. The default is &#39;false&#39;. (optional)
     * @param string $sort_order The order that the returned collection is sorted. The default is &#39;Ascending&#39;. (optional)
     * @param string $template_name Specify that included attributes must be members of this template. The default is no template filter. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\ItemsStreamValues, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamSetGetRecordedAtTimesWithHttpInfo($web_id, $time, $category_name = null, $name_filter = null, $retrieval_mode = null, $search_full_hierarchy = null, $selected_fields = null, $show_excluded = null, $show_hidden = null, $sort_order = null, $template_name = null, $time_zone = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling streamSetGetRecordedAtTimes');
        }
        // verify the required parameter 'time' is set
        if ($time === null) {
            throw new \InvalidArgumentException('Missing the required parameter $time when calling streamSetGetRecordedAtTimes');
        }
        // parse inputs
        $resourcePath = "/streamsets/{webId}/recordedattimes";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if (is_array($time)) {
            $time = $this->apiClient->getSerializer()->serializeCollection($time, 'multi', true);
        }
        if ($time !== null) {
            $queryParams['time'] = $this->apiClient->getSerializer()->toQueryValue($time);
        }
        // query params
        if ($category_name !== null) {
            $queryParams['categoryName'] = $this->apiClient->getSerializer()->toQueryValue($category_name);
        }
        // query params
        if ($name_filter !== null) {
            $queryParams['nameFilter'] = $this->apiClient->getSerializer()->toQueryValue($name_filter);
        }
        // query params
        if ($retrieval_mode !== null) {
            $queryParams['retrievalMode'] = $this->apiClient->getSerializer()->toQueryValue($retrieval_mode);
        }
        // query params
        if ($search_full_hierarchy !== null) {
            $queryParams['searchFullHierarchy'] = $this->apiClient->getSerializer()->toQueryValue($search_full_hierarchy);
        }
        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // query params
        if ($show_excluded !== null) {
            $queryParams['showExcluded'] = $this->apiClient->getSerializer()->toQueryValue($show_excluded);
        }
        // query params
        if ($show_hidden !== null) {
            $queryParams['showHidden'] = $this->apiClient->getSerializer()->toQueryValue($show_hidden);
        }
        // query params
        if ($sort_order !== null) {
            $queryParams['sortOrder'] = $this->apiClient->getSerializer()->toQueryValue($sort_order);
        }
        // query params
        if ($template_name !== null) {
            $queryParams['templateName'] = $this->apiClient->getSerializer()->toQueryValue($template_name);
        }
        // query params
        if ($time_zone !== null) {
            $queryParams['timeZone'] = $this->apiClient->getSerializer()->toQueryValue($time_zone);
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\ItemsStreamValues',
                '/streamsets/{webId}/recordedattimes'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\ItemsStreamValues', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsStreamValues', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 502:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation streamSetGetRecordedAtTimesAdHoc
     *
     * Returns recorded values of the specified streams at the specified times.
     *
     * @param string[] $time The timestamp at which to retrieve a recorded value. Multiple timestamps may be specified with multiple instances of the parameter. (required)
     * @param string[] $web_id The ID of a stream. Multiple streams may be specified with multiple instances of the parameter. (required)
     * @param string $retrieval_mode An optional value that determines the values to return when values don&#39;t exist at the exact time specified. The default is &#39;Auto&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string $sort_order The order that the returned collection is sorted. The default is &#39;Ascending&#39;. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\ItemsStreamValues
     */
    public function streamSetGetRecordedAtTimesAdHoc($time, $web_id, $retrieval_mode = null, $selected_fields = null, $sort_order = null, $time_zone = null)
    {
        list($response) = $this->streamSetGetRecordedAtTimesAdHocWithHttpInfo($time, $web_id, $retrieval_mode, $selected_fields, $sort_order, $time_zone);
        return $response;
    }

    /**
     * Operation streamSetGetRecordedAtTimesAdHocWithHttpInfo
     *
     * Returns recorded values of the specified streams at the specified times.
     *
     * @param string[] $time The timestamp at which to retrieve a recorded value. Multiple timestamps may be specified with multiple instances of the parameter. (required)
     * @param string[] $web_id The ID of a stream. Multiple streams may be specified with multiple instances of the parameter. (required)
     * @param string $retrieval_mode An optional value that determines the values to return when values don&#39;t exist at the exact time specified. The default is &#39;Auto&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string $sort_order The order that the returned collection is sorted. The default is &#39;Ascending&#39;. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\ItemsStreamValues, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamSetGetRecordedAtTimesAdHocWithHttpInfo($time, $web_id, $retrieval_mode = null, $selected_fields = null, $sort_order = null, $time_zone = null)
    {
        // verify the required parameter 'time' is set
        if ($time === null) {
            throw new \InvalidArgumentException('Missing the required parameter $time when calling streamSetGetRecordedAtTimesAdHoc');
        }
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling streamSetGetRecordedAtTimesAdHoc');
        }
        // parse inputs
        $resourcePath = "/streamsets/recordedattimes";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if (is_array($time)) {
            $time = $this->apiClient->getSerializer()->serializeCollection($time, 'multi', true);
        }
        if ($time !== null) {
            $queryParams['time'] = $this->apiClient->getSerializer()->toQueryValue($time);
        }
        // query params
        if (is_array($web_id)) {
            $web_id = $this->apiClient->getSerializer()->serializeCollection($web_id, 'multi', true);
        }
        if ($web_id !== null) {
            $queryParams['webId'] = $this->apiClient->getSerializer()->toQueryValue($web_id);
        }
        // query params
        if ($retrieval_mode !== null) {
            $queryParams['retrievalMode'] = $this->apiClient->getSerializer()->toQueryValue($retrieval_mode);
        }
        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // query params
        if ($sort_order !== null) {
            $queryParams['sortOrder'] = $this->apiClient->getSerializer()->toQueryValue($sort_order);
        }
        // query params
        if ($time_zone !== null) {
            $queryParams['timeZone'] = $this->apiClient->getSerializer()->toQueryValue($time_zone);
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\ItemsStreamValues',
                '/streamsets/recordedattimes'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\ItemsStreamValues', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsStreamValues', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 502:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation streamSetGetSummaries
     *
     * Returns summary values of the attributes for an element, event frame or attribute.
     *
     * @param string $web_id The ID of an element, event frame or attribute, which is the base element or parent of all the stream attributes. (required)
     * @param string $calculation_basis Specifies the method of evaluating the data over the time range. The default is &#39;TimeWeighted&#39;. (optional)
     * @param string $category_name Specify that included attributes must have this category. The default is no category filter. (optional)
     * @param string $end_time An optional end time. The default is &#39;*&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s end time, or &#39;*&#39; if that is not set. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order. (optional)
     * @param string $filter_expression A string containing a filter expression. Expression variables are relative to the attribute. Use &#39;.&#39; to reference the containing attribute. The default is no filtering. (optional)
     * @param string $name_filter The name query string used for filtering attributes. The default is no filter. (optional)
     * @param string $sample_interval A time span specifies how often the filter expression is evaluated when computing the summary for an interval, if the sampleType is &#39;Interval&#39;. (optional)
     * @param string $sample_type A flag which specifies one or more summaries to compute for each interval over the time range. The default is &#39;ExpressionRecordedValues&#39;. (optional)
     * @param bool $search_full_hierarchy Specifies if the search should include attributes nested further than the immediate attributes of the searchRoot. The default is &#39;false&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param bool $show_excluded Specified if the search should include attributes with the Excluded property set. The default is &#39;false&#39;. (optional)
     * @param bool $show_hidden Specified if the search should include attributes with the Hidden property set. The default is &#39;false&#39;. (optional)
     * @param string $start_time An optional start time. The default is &#39;*-1d&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s start time, or &#39;*-1d&#39; if that is not set. (optional)
     * @param string $summary_duration The duration of each summary interval. (optional)
     * @param string[] $summary_type Specifies the kinds of summaries to produce over the range. The default is &#39;Total&#39;. Multiple summary types may be specified by using multiple instances of summaryType. (optional)
     * @param string $template_name Specify that included attributes must be members of this template. The default is no template filter. (optional)
     * @param string $time_type Specifies how to calculate the timestamp for each interval. The default is &#39;Auto&#39;. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\ItemsStreamSummaries
     */
    public function streamSetGetSummaries($web_id, $calculation_basis = null, $category_name = null, $end_time = null, $filter_expression = null, $name_filter = null, $sample_interval = null, $sample_type = null, $search_full_hierarchy = null, $selected_fields = null, $show_excluded = null, $show_hidden = null, $start_time = null, $summary_duration = null, $summary_type = null, $template_name = null, $time_type = null, $time_zone = null)
    {
        list($response) = $this->streamSetGetSummariesWithHttpInfo($web_id, $calculation_basis, $category_name, $end_time, $filter_expression, $name_filter, $sample_interval, $sample_type, $search_full_hierarchy, $selected_fields, $show_excluded, $show_hidden, $start_time, $summary_duration, $summary_type, $template_name, $time_type, $time_zone);
        return $response;
    }

    /**
     * Operation streamSetGetSummariesWithHttpInfo
     *
     * Returns summary values of the attributes for an element, event frame or attribute.
     *
     * @param string $web_id The ID of an element, event frame or attribute, which is the base element or parent of all the stream attributes. (required)
     * @param string $calculation_basis Specifies the method of evaluating the data over the time range. The default is &#39;TimeWeighted&#39;. (optional)
     * @param string $category_name Specify that included attributes must have this category. The default is no category filter. (optional)
     * @param string $end_time An optional end time. The default is &#39;*&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s end time, or &#39;*&#39; if that is not set. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order. (optional)
     * @param string $filter_expression A string containing a filter expression. Expression variables are relative to the attribute. Use &#39;.&#39; to reference the containing attribute. The default is no filtering. (optional)
     * @param string $name_filter The name query string used for filtering attributes. The default is no filter. (optional)
     * @param string $sample_interval A time span specifies how often the filter expression is evaluated when computing the summary for an interval, if the sampleType is &#39;Interval&#39;. (optional)
     * @param string $sample_type A flag which specifies one or more summaries to compute for each interval over the time range. The default is &#39;ExpressionRecordedValues&#39;. (optional)
     * @param bool $search_full_hierarchy Specifies if the search should include attributes nested further than the immediate attributes of the searchRoot. The default is &#39;false&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param bool $show_excluded Specified if the search should include attributes with the Excluded property set. The default is &#39;false&#39;. (optional)
     * @param bool $show_hidden Specified if the search should include attributes with the Hidden property set. The default is &#39;false&#39;. (optional)
     * @param string $start_time An optional start time. The default is &#39;*-1d&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s start time, or &#39;*-1d&#39; if that is not set. (optional)
     * @param string $summary_duration The duration of each summary interval. (optional)
     * @param string[] $summary_type Specifies the kinds of summaries to produce over the range. The default is &#39;Total&#39;. Multiple summary types may be specified by using multiple instances of summaryType. (optional)
     * @param string $template_name Specify that included attributes must be members of this template. The default is no template filter. (optional)
     * @param string $time_type Specifies how to calculate the timestamp for each interval. The default is &#39;Auto&#39;. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\ItemsStreamSummaries, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamSetGetSummariesWithHttpInfo($web_id, $calculation_basis = null, $category_name = null, $end_time = null, $filter_expression = null, $name_filter = null, $sample_interval = null, $sample_type = null, $search_full_hierarchy = null, $selected_fields = null, $show_excluded = null, $show_hidden = null, $start_time = null, $summary_duration = null, $summary_type = null, $template_name = null, $time_type = null, $time_zone = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling streamSetGetSummaries');
        }
        // parse inputs
        $resourcePath = "/streamsets/{webId}/summary";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($calculation_basis !== null) {
            $queryParams['calculationBasis'] = $this->apiClient->getSerializer()->toQueryValue($calculation_basis);
        }
        // query params
        if ($category_name !== null) {
            $queryParams['categoryName'] = $this->apiClient->getSerializer()->toQueryValue($category_name);
        }
        // query params
        if ($end_time !== null) {
            $queryParams['endTime'] = $this->apiClient->getSerializer()->toQueryValue($end_time);
        }
        // query params
        if ($filter_expression !== null) {
            $queryParams['filterExpression'] = $this->apiClient->getSerializer()->toQueryValue($filter_expression);
        }
        // query params
        if ($name_filter !== null) {
            $queryParams['nameFilter'] = $this->apiClient->getSerializer()->toQueryValue($name_filter);
        }
        // query params
        if ($sample_interval !== null) {
            $queryParams['sampleInterval'] = $this->apiClient->getSerializer()->toQueryValue($sample_interval);
        }
        // query params
        if ($sample_type !== null) {
            $queryParams['sampleType'] = $this->apiClient->getSerializer()->toQueryValue($sample_type);
        }
        // query params
        if ($search_full_hierarchy !== null) {
            $queryParams['searchFullHierarchy'] = $this->apiClient->getSerializer()->toQueryValue($search_full_hierarchy);
        }
        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // query params
        if ($show_excluded !== null) {
            $queryParams['showExcluded'] = $this->apiClient->getSerializer()->toQueryValue($show_excluded);
        }
        // query params
        if ($show_hidden !== null) {
            $queryParams['showHidden'] = $this->apiClient->getSerializer()->toQueryValue($show_hidden);
        }
        // query params
        if ($start_time !== null) {
            $queryParams['startTime'] = $this->apiClient->getSerializer()->toQueryValue($start_time);
        }
        // query params
        if ($summary_duration !== null) {
            $queryParams['summaryDuration'] = $this->apiClient->getSerializer()->toQueryValue($summary_duration);
        }
        // query params
        if (is_array($summary_type)) {
            $summary_type = $this->apiClient->getSerializer()->serializeCollection($summary_type, 'multi', true);
        }
        if ($summary_type !== null) {
            $queryParams['summaryType'] = $this->apiClient->getSerializer()->toQueryValue($summary_type);
        }
        // query params
        if ($template_name !== null) {
            $queryParams['templateName'] = $this->apiClient->getSerializer()->toQueryValue($template_name);
        }
        // query params
        if ($time_type !== null) {
            $queryParams['timeType'] = $this->apiClient->getSerializer()->toQueryValue($time_type);
        }
        // query params
        if ($time_zone !== null) {
            $queryParams['timeZone'] = $this->apiClient->getSerializer()->toQueryValue($time_zone);
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\ItemsStreamSummaries',
                '/streamsets/{webId}/summary'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\ItemsStreamSummaries', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsStreamSummaries', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation streamSetGetSummariesAdHoc
     *
     * Returns summary values of the specified streams.
     *
     * @param string[] $web_id The ID of a stream.  Multiple streams may be specified with multiple instances of the parameter. (required)
     * @param string $calculation_basis Specifies the method of evaluating the data over the time range. The default is &#39;TimeWeighted&#39;. (optional)
     * @param string $end_time An optional end time. The default is &#39;*&#39;. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order. (optional)
     * @param string $filter_expression A string containing a filter expression. Expression variables are relative to the attribute. Use &#39;.&#39; to reference the containing attribute. The default is no filtering. (optional)
     * @param string $sample_interval A time span specifies how often the filter expression is evaluated when computing the summary for an interval, if the sampleType is &#39;Interval&#39;. (optional)
     * @param string $sample_type A flag which specifies one or more summaries to compute for each interval over the time range. The default is &#39;ExpressionRecordedValues&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string $start_time An optional start time. The default is &#39;*-1d&#39;. (optional)
     * @param string $summary_duration The duration of each summary interval. (optional)
     * @param string[] $summary_type Specifies the kinds of summaries to produce over the range. The default is &#39;Total&#39;. Multiple summary types may be specified by using multiple instances of summaryType. (optional)
     * @param string $time_type Specifies how to calculate the timestamp for each interval. The default is &#39;Auto&#39;. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\ItemsStreamSummaries
     */
    public function streamSetGetSummariesAdHoc($web_id, $calculation_basis = null, $end_time = null, $filter_expression = null, $sample_interval = null, $sample_type = null, $selected_fields = null, $start_time = null, $summary_duration = null, $summary_type = null, $time_type = null, $time_zone = null)
    {
        list($response) = $this->streamSetGetSummariesAdHocWithHttpInfo($web_id, $calculation_basis, $end_time, $filter_expression, $sample_interval, $sample_type, $selected_fields, $start_time, $summary_duration, $summary_type, $time_type, $time_zone);
        return $response;
    }

    /**
     * Operation streamSetGetSummariesAdHocWithHttpInfo
     *
     * Returns summary values of the specified streams.
     *
     * @param string[] $web_id The ID of a stream.  Multiple streams may be specified with multiple instances of the parameter. (required)
     * @param string $calculation_basis Specifies the method of evaluating the data over the time range. The default is &#39;TimeWeighted&#39;. (optional)
     * @param string $end_time An optional end time. The default is &#39;*&#39;. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order. (optional)
     * @param string $filter_expression A string containing a filter expression. Expression variables are relative to the attribute. Use &#39;.&#39; to reference the containing attribute. The default is no filtering. (optional)
     * @param string $sample_interval A time span specifies how often the filter expression is evaluated when computing the summary for an interval, if the sampleType is &#39;Interval&#39;. (optional)
     * @param string $sample_type A flag which specifies one or more summaries to compute for each interval over the time range. The default is &#39;ExpressionRecordedValues&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string $start_time An optional start time. The default is &#39;*-1d&#39;. (optional)
     * @param string $summary_duration The duration of each summary interval. (optional)
     * @param string[] $summary_type Specifies the kinds of summaries to produce over the range. The default is &#39;Total&#39;. Multiple summary types may be specified by using multiple instances of summaryType. (optional)
     * @param string $time_type Specifies how to calculate the timestamp for each interval. The default is &#39;Auto&#39;. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\ItemsStreamSummaries, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamSetGetSummariesAdHocWithHttpInfo($web_id, $calculation_basis = null, $end_time = null, $filter_expression = null, $sample_interval = null, $sample_type = null, $selected_fields = null, $start_time = null, $summary_duration = null, $summary_type = null, $time_type = null, $time_zone = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling streamSetGetSummariesAdHoc');
        }
        // parse inputs
        $resourcePath = "/streamsets/summary";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if (is_array($web_id)) {
            $web_id = $this->apiClient->getSerializer()->serializeCollection($web_id, 'multi', true);
        }
        if ($web_id !== null) {
            $queryParams['webId'] = $this->apiClient->getSerializer()->toQueryValue($web_id);
        }
        // query params
        if ($calculation_basis !== null) {
            $queryParams['calculationBasis'] = $this->apiClient->getSerializer()->toQueryValue($calculation_basis);
        }
        // query params
        if ($end_time !== null) {
            $queryParams['endTime'] = $this->apiClient->getSerializer()->toQueryValue($end_time);
        }
        // query params
        if ($filter_expression !== null) {
            $queryParams['filterExpression'] = $this->apiClient->getSerializer()->toQueryValue($filter_expression);
        }
        // query params
        if ($sample_interval !== null) {
            $queryParams['sampleInterval'] = $this->apiClient->getSerializer()->toQueryValue($sample_interval);
        }
        // query params
        if ($sample_type !== null) {
            $queryParams['sampleType'] = $this->apiClient->getSerializer()->toQueryValue($sample_type);
        }
        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // query params
        if ($start_time !== null) {
            $queryParams['startTime'] = $this->apiClient->getSerializer()->toQueryValue($start_time);
        }
        // query params
        if ($summary_duration !== null) {
            $queryParams['summaryDuration'] = $this->apiClient->getSerializer()->toQueryValue($summary_duration);
        }
        // query params
        if (is_array($summary_type)) {
            $summary_type = $this->apiClient->getSerializer()->serializeCollection($summary_type, 'multi', true);
        }
        if ($summary_type !== null) {
            $queryParams['summaryType'] = $this->apiClient->getSerializer()->toQueryValue($summary_type);
        }
        // query params
        if ($time_type !== null) {
            $queryParams['timeType'] = $this->apiClient->getSerializer()->toQueryValue($time_type);
        }
        // query params
        if ($time_zone !== null) {
            $queryParams['timeZone'] = $this->apiClient->getSerializer()->toQueryValue($time_zone);
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\ItemsStreamSummaries',
                '/streamsets/summary'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\ItemsStreamSummaries', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsStreamSummaries', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation streamSetGetValues
     *
     * Returns values of the attributes for an Element, Event Frame or Attribute at the specified time.
     *
     * @param string $web_id The ID of an Element, Event Frame or Attribute, which is the base element or parent of all the stream attributes. (required)
     * @param string $category_name Specify that included attributes must have this category. The default is no category filter. (optional)
     * @param string $name_filter The name query string used for filtering attributes. The default is no filter. (optional)
     * @param bool $search_full_hierarchy Specifies if the search should include attributes nested further than the immediate attributes of the searchRoot. The default is &#39;false&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param bool $show_excluded Specified if the search should include attributes with the Excluded property set. The default is &#39;false&#39;. (optional)
     * @param bool $show_hidden Specified if the search should include attributes with the Hidden property set. The default is &#39;false&#39;. (optional)
     * @param string $template_name Specify that included attributes must be members of this template. The default is no template filter. (optional)
     * @param string $time An AF time string, which is used as the time context to get stream values if it is provided. By default, it is not specified, and the default time context of the AF object will be used. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\ItemsStreamValue
     */
    public function streamSetGetValues($web_id, $category_name = null, $name_filter = null, $search_full_hierarchy = null, $selected_fields = null, $show_excluded = null, $show_hidden = null, $template_name = null, $time = null, $time_zone = null)
    {
        list($response) = $this->streamSetGetValuesWithHttpInfo($web_id, $category_name, $name_filter, $search_full_hierarchy, $selected_fields, $show_excluded, $show_hidden, $template_name, $time, $time_zone);
        return $response;
    }

    /**
     * Operation streamSetGetValuesWithHttpInfo
     *
     * Returns values of the attributes for an Element, Event Frame or Attribute at the specified time.
     *
     * @param string $web_id The ID of an Element, Event Frame or Attribute, which is the base element or parent of all the stream attributes. (required)
     * @param string $category_name Specify that included attributes must have this category. The default is no category filter. (optional)
     * @param string $name_filter The name query string used for filtering attributes. The default is no filter. (optional)
     * @param bool $search_full_hierarchy Specifies if the search should include attributes nested further than the immediate attributes of the searchRoot. The default is &#39;false&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param bool $show_excluded Specified if the search should include attributes with the Excluded property set. The default is &#39;false&#39;. (optional)
     * @param bool $show_hidden Specified if the search should include attributes with the Hidden property set. The default is &#39;false&#39;. (optional)
     * @param string $template_name Specify that included attributes must be members of this template. The default is no template filter. (optional)
     * @param string $time An AF time string, which is used as the time context to get stream values if it is provided. By default, it is not specified, and the default time context of the AF object will be used. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\ItemsStreamValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamSetGetValuesWithHttpInfo($web_id, $category_name = null, $name_filter = null, $search_full_hierarchy = null, $selected_fields = null, $show_excluded = null, $show_hidden = null, $template_name = null, $time = null, $time_zone = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling streamSetGetValues');
        }
        // parse inputs
        $resourcePath = "/streamsets/{webId}/value";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($category_name !== null) {
            $queryParams['categoryName'] = $this->apiClient->getSerializer()->toQueryValue($category_name);
        }
        // query params
        if ($name_filter !== null) {
            $queryParams['nameFilter'] = $this->apiClient->getSerializer()->toQueryValue($name_filter);
        }
        // query params
        if ($search_full_hierarchy !== null) {
            $queryParams['searchFullHierarchy'] = $this->apiClient->getSerializer()->toQueryValue($search_full_hierarchy);
        }
        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // query params
        if ($show_excluded !== null) {
            $queryParams['showExcluded'] = $this->apiClient->getSerializer()->toQueryValue($show_excluded);
        }
        // query params
        if ($show_hidden !== null) {
            $queryParams['showHidden'] = $this->apiClient->getSerializer()->toQueryValue($show_hidden);
        }
        // query params
        if ($template_name !== null) {
            $queryParams['templateName'] = $this->apiClient->getSerializer()->toQueryValue($template_name);
        }
        // query params
        if ($time !== null) {
            $queryParams['time'] = $this->apiClient->getSerializer()->toQueryValue($time);
        }
        // query params
        if ($time_zone !== null) {
            $queryParams['timeZone'] = $this->apiClient->getSerializer()->toQueryValue($time_zone);
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\ItemsStreamValue',
                '/streamsets/{webId}/value'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\ItemsStreamValue', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsStreamValue', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation streamSetGetValuesAdHoc
     *
     * Returns values of the specified streams.
     *
     * @param string[] $web_id The ID of a stream.  Multiple streams may be specified with multiple instances of the parameter. (required)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string $time An AF time string, which is used as the time context to get stream values if it is provided. By default, it is not specified, and the default time context of the AF object will be used. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\ItemsStreamValue
     */
    public function streamSetGetValuesAdHoc($web_id, $selected_fields = null, $time = null, $time_zone = null)
    {
        list($response) = $this->streamSetGetValuesAdHocWithHttpInfo($web_id, $selected_fields, $time, $time_zone);
        return $response;
    }

    /**
     * Operation streamSetGetValuesAdHocWithHttpInfo
     *
     * Returns values of the specified streams.
     *
     * @param string[] $web_id The ID of a stream.  Multiple streams may be specified with multiple instances of the parameter. (required)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string $time An AF time string, which is used as the time context to get stream values if it is provided. By default, it is not specified, and the default time context of the AF object will be used. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\ItemsStreamValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamSetGetValuesAdHocWithHttpInfo($web_id, $selected_fields = null, $time = null, $time_zone = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling streamSetGetValuesAdHoc');
        }
        // parse inputs
        $resourcePath = "/streamsets/value";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if (is_array($web_id)) {
            $web_id = $this->apiClient->getSerializer()->serializeCollection($web_id, 'multi', true);
        }
        if ($web_id !== null) {
            $queryParams['webId'] = $this->apiClient->getSerializer()->toQueryValue($web_id);
        }
        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // query params
        if ($time !== null) {
            $queryParams['time'] = $this->apiClient->getSerializer()->toQueryValue($time);
        }
        // query params
        if ($time_zone !== null) {
            $queryParams['timeZone'] = $this->apiClient->getSerializer()->toQueryValue($time_zone);
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\ItemsStreamValue',
                '/streamsets/value'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\ItemsStreamValue', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsStreamValue', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation streamSetUpdateValue
     *
     * Updates a single value for the specified streams.
     *
     * @param string $web_id The ID of the parent element, event frame, or attribute. Attributes specified in the body must be descendants of the specified object. (required)
     * @param \PIWebAPI\Client\Model\StreamValue[] $values The values to add or update. (required)
     * @param string $buffer_option The desired AFBufferOption. The default is &#39;BufferIfPossible&#39;. (optional)
     * @param string $update_option The desired AFUpdateOption. The default is &#39;Replace&#39;. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\ItemsSubstatus
     */
    public function streamSetUpdateValue($web_id, $values, $buffer_option = null, $update_option = null)
    {
        list($response) = $this->streamSetUpdateValueWithHttpInfo($web_id, $values, $buffer_option, $update_option);
        return $response;
    }

    /**
     * Operation streamSetUpdateValueWithHttpInfo
     *
     * Updates a single value for the specified streams.
     *
     * @param string $web_id The ID of the parent element, event frame, or attribute. Attributes specified in the body must be descendants of the specified object. (required)
     * @param \PIWebAPI\Client\Model\StreamValue[] $values The values to add or update. (required)
     * @param string $buffer_option The desired AFBufferOption. The default is &#39;BufferIfPossible&#39;. (optional)
     * @param string $update_option The desired AFUpdateOption. The default is &#39;Replace&#39;. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\ItemsSubstatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamSetUpdateValueWithHttpInfo($web_id, $values, $buffer_option = null, $update_option = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling streamSetUpdateValue');
        }
        // verify the required parameter 'values' is set
        if ($values === null) {
            throw new \InvalidArgumentException('Missing the required parameter $values when calling streamSetUpdateValue');
        }
        // parse inputs
        $resourcePath = "/streamsets/{webId}/value";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json', 'text/json']);

        // query params
        if ($buffer_option !== null) {
            $queryParams['bufferOption'] = $this->apiClient->getSerializer()->toQueryValue($buffer_option);
        }
        // query params
        if ($update_option !== null) {
            $queryParams['updateOption'] = $this->apiClient->getSerializer()->toQueryValue($update_option);
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($values)) {
            $_tempBody = $values;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\ItemsSubstatus',
                '/streamsets/{webId}/value'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\ItemsSubstatus', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsSubstatus', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 207:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsSubstatus', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation streamSetUpdateValueAdHoc
     *
     * Updates a single value for the specified streams.
     *
     * @param \PIWebAPI\Client\Model\StreamValues[] $values The values to add or update. (required)
     * @param string $buffer_option The desired AFBufferOption. The default is &#39;BufferIfPossible&#39;. (optional)
     * @param string $update_option The desired AFUpdateOption. The default is &#39;Replace&#39;. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\ItemsSubstatus
     */
    public function streamSetUpdateValueAdHoc($values, $buffer_option = null, $update_option = null)
    {
        list($response) = $this->streamSetUpdateValueAdHocWithHttpInfo($values, $buffer_option, $update_option);
        return $response;
    }

    /**
     * Operation streamSetUpdateValueAdHocWithHttpInfo
     *
     * Updates a single value for the specified streams.
     *
     * @param \PIWebAPI\Client\Model\StreamValues[] $values The values to add or update. (required)
     * @param string $buffer_option The desired AFBufferOption. The default is &#39;BufferIfPossible&#39;. (optional)
     * @param string $update_option The desired AFUpdateOption. The default is &#39;Replace&#39;. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\ItemsSubstatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamSetUpdateValueAdHocWithHttpInfo($values, $buffer_option = null, $update_option = null)
    {
        // verify the required parameter 'values' is set
        if ($values === null) {
            throw new \InvalidArgumentException('Missing the required parameter $values when calling streamSetUpdateValueAdHoc');
        }
        // parse inputs
        $resourcePath = "/streamsets/value";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json', 'text/json']);

        // query params
        if ($buffer_option !== null) {
            $queryParams['bufferOption'] = $this->apiClient->getSerializer()->toQueryValue($buffer_option);
        }
        // query params
        if ($update_option !== null) {
            $queryParams['updateOption'] = $this->apiClient->getSerializer()->toQueryValue($update_option);
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($values)) {
            $_tempBody = $values;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\ItemsSubstatus',
                '/streamsets/value'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\ItemsSubstatus', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsSubstatus', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 207:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsSubstatus', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation streamSetUpdateValues
     *
     * Updates multiple values for the specified streams.
     *
     * @param string $web_id The ID of the parent element, event frame, or attribute. Attributes specified in the body must be descendants of the specified object. (required)
     * @param \PIWebAPI\Client\Model\StreamValues[] $values The values to add or update. (required)
     * @param string $buffer_option The desired AFBufferOption. The default is &#39;BufferIfPossible&#39;. (optional)
     * @param string $update_option The desired AFUpdateOption. The default is &#39;Replace&#39;. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\ItemsItemsSubstatus
     */
    public function streamSetUpdateValues($web_id, $values, $buffer_option = null, $update_option = null)
    {
        list($response) = $this->streamSetUpdateValuesWithHttpInfo($web_id, $values, $buffer_option, $update_option);
        return $response;
    }

    /**
     * Operation streamSetUpdateValuesWithHttpInfo
     *
     * Updates multiple values for the specified streams.
     *
     * @param string $web_id The ID of the parent element, event frame, or attribute. Attributes specified in the body must be descendants of the specified object. (required)
     * @param \PIWebAPI\Client\Model\StreamValues[] $values The values to add or update. (required)
     * @param string $buffer_option The desired AFBufferOption. The default is &#39;BufferIfPossible&#39;. (optional)
     * @param string $update_option The desired AFUpdateOption. The default is &#39;Replace&#39;. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\ItemsItemsSubstatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamSetUpdateValuesWithHttpInfo($web_id, $values, $buffer_option = null, $update_option = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling streamSetUpdateValues');
        }
        // verify the required parameter 'values' is set
        if ($values === null) {
            throw new \InvalidArgumentException('Missing the required parameter $values when calling streamSetUpdateValues');
        }
        // parse inputs
        $resourcePath = "/streamsets/{webId}/recorded";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json', 'text/json']);

        // query params
        if ($buffer_option !== null) {
            $queryParams['bufferOption'] = $this->apiClient->getSerializer()->toQueryValue($buffer_option);
        }
        // query params
        if ($update_option !== null) {
            $queryParams['updateOption'] = $this->apiClient->getSerializer()->toQueryValue($update_option);
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($values)) {
            $_tempBody = $values;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\ItemsItemsSubstatus',
                '/streamsets/{webId}/recorded'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\ItemsItemsSubstatus', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsItemsSubstatus', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 207:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsItemsSubstatus', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation streamSetUpdateValuesAdHoc
     *
     * Updates multiple values for the specified streams.
     *
     * @param \PIWebAPI\Client\Model\StreamValues[] $values The values to add or update. (required)
     * @param string $buffer_option The desired AFBufferOption. The default is &#39;BufferIfPossible&#39;. (optional)
     * @param string $update_option The desired AFUpdateOption. The default is &#39;Replace&#39;. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\ItemsItemsSubstatus
     */
    public function streamSetUpdateValuesAdHoc($values, $buffer_option = null, $update_option = null)
    {
        list($response) = $this->streamSetUpdateValuesAdHocWithHttpInfo($values, $buffer_option, $update_option);
        return $response;
    }

    /**
     * Operation streamSetUpdateValuesAdHocWithHttpInfo
     *
     * Updates multiple values for the specified streams.
     *
     * @param \PIWebAPI\Client\Model\StreamValues[] $values The values to add or update. (required)
     * @param string $buffer_option The desired AFBufferOption. The default is &#39;BufferIfPossible&#39;. (optional)
     * @param string $update_option The desired AFUpdateOption. The default is &#39;Replace&#39;. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\ItemsItemsSubstatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamSetUpdateValuesAdHocWithHttpInfo($values, $buffer_option = null, $update_option = null)
    {
        // verify the required parameter 'values' is set
        if ($values === null) {
            throw new \InvalidArgumentException('Missing the required parameter $values when calling streamSetUpdateValuesAdHoc');
        }
        // parse inputs
        $resourcePath = "/streamsets/recorded";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json', 'text/json']);

        // query params
        if ($buffer_option !== null) {
            $queryParams['bufferOption'] = $this->apiClient->getSerializer()->toQueryValue($buffer_option);
        }
        // query params
        if ($update_option !== null) {
            $queryParams['updateOption'] = $this->apiClient->getSerializer()->toQueryValue($update_option);
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($values)) {
            $_tempBody = $values;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\ItemsItemsSubstatus',
                '/streamsets/recorded'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\ItemsItemsSubstatus', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsItemsSubstatus', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 207:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsItemsSubstatus', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }
}
