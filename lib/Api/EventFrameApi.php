<?php
/**
 * EventFrameApi
 * PHP version 5
 *
 * @category Class
 * @package  PIWebAPI\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * PI Web API 2017 Swagger Spec
 *
 * Swagger Spec file that describes PI Web API
 *
 * OpenAPI spec version: 1.9.0.235
 * Contact: techsupport@osisoft.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace PIWebAPI\Client\Api;

use \PIWebAPI\Client\ApiClient;
use \PIWebAPI\Client\ApiException;
use \PIWebAPI\Client\Configuration;
use \PIWebAPI\Client\ObjectSerializer;

/**
 * EventFrameApi Class Doc Comment
 *
 * @category Class
 * @package  PIWebAPI\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class EventFrameApi
{
    /**
     * API Client
     *
     * @var \PIWebAPI\Client\ApiClient instance of the ApiClient
     */
    protected $apiClient;

    /**
     * Constructor
     *
     * @param \PIWebAPI\Client\ApiClient|null $apiClient The api client to use
     */
    public function __construct(\PIWebAPI\Client\ApiClient $apiClient = null)
    {
        if ($apiClient === null) {
            $apiClient = new ApiClient();
            $apiClient->getConfig()->setHost('https://proghackuc2017.osisoft.com/piwebapi');
        }

        $this->apiClient = $apiClient;
    }

    /**
     * Get API client
     *
     * @return \PIWebAPI\Client\ApiClient get the API client
     */
    public function getApiClient()
    {
        return $this->apiClient;
    }

    /**
     * Set the API client
     *
     * @param \PIWebAPI\Client\ApiClient $apiClient set the API client
     *
     * @return EventFrameApi
     */
    public function setApiClient(\PIWebAPI\Client\ApiClient $apiClient)
    {
        $this->apiClient = $apiClient;
        return $this;
    }

    /**
     * Operation eventFrameAcknowledge
     *
     * Calls the EventFrame's Acknowledge method.
     *
     * @param string $web_id The ID of the event frame. (required)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return void
     */
    public function eventFrameAcknowledge($web_id)
    {
        list($response) = $this->eventFrameAcknowledgeWithHttpInfo($web_id);
        return $response;
    }

    /**
     * Operation eventFrameAcknowledgeWithHttpInfo
     *
     * Calls the EventFrame's Acknowledge method.
     *
     * @param string $web_id The ID of the event frame. (required)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventFrameAcknowledgeWithHttpInfo($web_id)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling eventFrameAcknowledge');
        }
        // parse inputs
        $resourcePath = "/eventframes/{webId}/acknowledge";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json', 'text/json']);

        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PATCH',
                $queryParams,
                $httpBody,
                $headerParams,
                null,
                '/eventframes/{webId}/acknowledge'
            );

            return [null, $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }

            throw $e;
        }
    }

    /**
     * Operation eventFrameCaptureValues
     *
     * Calls the EventFrame's CaptureValues method.
     *
     * @param string $web_id The ID of the event frame. (required)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return void
     */
    public function eventFrameCaptureValues($web_id)
    {
        list($response) = $this->eventFrameCaptureValuesWithHttpInfo($web_id);
        return $response;
    }

    /**
     * Operation eventFrameCaptureValuesWithHttpInfo
     *
     * Calls the EventFrame's CaptureValues method.
     *
     * @param string $web_id The ID of the event frame. (required)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventFrameCaptureValuesWithHttpInfo($web_id)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling eventFrameCaptureValues');
        }
        // parse inputs
        $resourcePath = "/eventframes/{webId}/attributes/capture";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json', 'text/json']);

        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                null,
                '/eventframes/{webId}/attributes/capture'
            );

            return [null, $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }

            throw $e;
        }
    }

    /**
     * Operation eventFrameCreateAnnotation
     *
     * Create an annotation on an event frame.
     *
     * @param string $web_id The ID of the owner event frame on which to create the annotation. (required)
     * @param \PIWebAPI\Client\Model\Annotation $annotation The new annotation definition. (required)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return void
     */
    public function eventFrameCreateAnnotation($web_id, $annotation)
    {
        list($response) = $this->eventFrameCreateAnnotationWithHttpInfo($web_id, $annotation);
        return $response;
    }

    /**
     * Operation eventFrameCreateAnnotationWithHttpInfo
     *
     * Create an annotation on an event frame.
     *
     * @param string $web_id The ID of the owner event frame on which to create the annotation. (required)
     * @param \PIWebAPI\Client\Model\Annotation $annotation The new annotation definition. (required)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventFrameCreateAnnotationWithHttpInfo($web_id, $annotation)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling eventFrameCreateAnnotation');
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException('Missing the required parameter $annotation when calling eventFrameCreateAnnotation');
        }
        // parse inputs
        $resourcePath = "/eventframes/{webId}/annotations";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json', 'text/json']);

        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                null,
                '/eventframes/{webId}/annotations'
            );

            return [null, $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }

            throw $e;
        }
    }

    /**
     * Operation eventFrameCreateAttribute
     *
     * Create a new attribute of the specified event frame.
     *
     * @param string $web_id The ID of the event frame on which to create the attribute. (required)
     * @param \PIWebAPI\Client\Model\Attribute $attribute The definition of the new attribute. (required)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return void
     */
    public function eventFrameCreateAttribute($web_id, $attribute)
    {
        list($response) = $this->eventFrameCreateAttributeWithHttpInfo($web_id, $attribute);
        return $response;
    }

    /**
     * Operation eventFrameCreateAttributeWithHttpInfo
     *
     * Create a new attribute of the specified event frame.
     *
     * @param string $web_id The ID of the event frame on which to create the attribute. (required)
     * @param \PIWebAPI\Client\Model\Attribute $attribute The definition of the new attribute. (required)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventFrameCreateAttributeWithHttpInfo($web_id, $attribute)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling eventFrameCreateAttribute');
        }
        // verify the required parameter 'attribute' is set
        if ($attribute === null) {
            throw new \InvalidArgumentException('Missing the required parameter $attribute when calling eventFrameCreateAttribute');
        }
        // parse inputs
        $resourcePath = "/eventframes/{webId}/attributes";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json', 'text/json']);

        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($attribute)) {
            $_tempBody = $attribute;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                null,
                '/eventframes/{webId}/attributes'
            );

            return [null, $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }

            throw $e;
        }
    }

    /**
     * Operation eventFrameCreateConfig
     *
     * Executes the create configuration function of the data references found within the attributes of the event frame, and optionally, its children.
     *
     * @param string $web_id The ID of the event frame. (required)
     * @param bool $include_child_elements If true, includes the child event frames of the specified event frame. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return void
     */
    public function eventFrameCreateConfig($web_id, $include_child_elements = null)
    {
        list($response) = $this->eventFrameCreateConfigWithHttpInfo($web_id, $include_child_elements);
        return $response;
    }

    /**
     * Operation eventFrameCreateConfigWithHttpInfo
     *
     * Executes the create configuration function of the data references found within the attributes of the event frame, and optionally, its children.
     *
     * @param string $web_id The ID of the event frame. (required)
     * @param bool $include_child_elements If true, includes the child event frames of the specified event frame. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventFrameCreateConfigWithHttpInfo($web_id, $include_child_elements = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling eventFrameCreateConfig');
        }
        // parse inputs
        $resourcePath = "/eventframes/{webId}/config";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json', 'text/json']);

        // query params
        if ($include_child_elements !== null) {
            $queryParams['includeChildElements'] = $this->apiClient->getSerializer()->toQueryValue($include_child_elements);
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                null,
                '/eventframes/{webId}/config'
            );

            return [null, $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }

            throw $e;
        }
    }

    /**
     * Operation eventFrameCreateEventFrame
     *
     * Create an event frame as a child of the specified event frame.
     *
     * @param string $web_id The ID of the parent event frame on which to create the event frame. (required)
     * @param \PIWebAPI\Client\Model\EventFrame $event_frame The new event frame definition. (required)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return void
     */
    public function eventFrameCreateEventFrame($web_id, $event_frame)
    {
        list($response) = $this->eventFrameCreateEventFrameWithHttpInfo($web_id, $event_frame);
        return $response;
    }

    /**
     * Operation eventFrameCreateEventFrameWithHttpInfo
     *
     * Create an event frame as a child of the specified event frame.
     *
     * @param string $web_id The ID of the parent event frame on which to create the event frame. (required)
     * @param \PIWebAPI\Client\Model\EventFrame $event_frame The new event frame definition. (required)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventFrameCreateEventFrameWithHttpInfo($web_id, $event_frame)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling eventFrameCreateEventFrame');
        }
        // verify the required parameter 'event_frame' is set
        if ($event_frame === null) {
            throw new \InvalidArgumentException('Missing the required parameter $event_frame when calling eventFrameCreateEventFrame');
        }
        // parse inputs
        $resourcePath = "/eventframes/{webId}/eventframes";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json', 'text/json']);

        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($event_frame)) {
            $_tempBody = $event_frame;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                null,
                '/eventframes/{webId}/eventframes'
            );

            return [null, $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }

            throw $e;
        }
    }

    /**
     * Operation eventFrameCreateSearchByAttribute
     *
     * Create a link for a \"Search EventFrames By Attribute Value\" operation, whose queries are specified in the request content. The SearchRoot is specified by the Web Id of the root EventFrame. If the SearchRoot is not specified, then the search starts at the Asset Database. ElementTemplate must be provided as the Web ID of the ElementTemplate, which are used to create the EventFrames. All the attributes in the queries must be defined as AttributeTemplates on the ElementTemplate. An array of attribute value queries are ANDed together to find the desired Element objects. At least one value query must be specified. There are limitations on SearchOperators.
     *
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return void
     */
    public function eventFrameCreateSearchByAttribute()
    {
        list($response) = $this->eventFrameCreateSearchByAttributeWithHttpInfo();
        return $response;
    }

    /**
     * Operation eventFrameCreateSearchByAttributeWithHttpInfo
     *
     * Create a link for a \"Search EventFrames By Attribute Value\" operation, whose queries are specified in the request content. The SearchRoot is specified by the Web Id of the root EventFrame. If the SearchRoot is not specified, then the search starts at the Asset Database. ElementTemplate must be provided as the Web ID of the ElementTemplate, which are used to create the EventFrames. All the attributes in the queries must be defined as AttributeTemplates on the ElementTemplate. An array of attribute value queries are ANDed together to find the desired Element objects. At least one value query must be specified. There are limitations on SearchOperators.
     *
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventFrameCreateSearchByAttributeWithHttpInfo()
    {
        // parse inputs
        $resourcePath = "/eventframes/searchbyattribute";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json', 'text/json']);

        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                null,
                '/eventframes/searchbyattribute'
            );

            return [null, $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 413:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation eventFrameCreateSecurityEntry
     *
     * Create a security entry owned by the event frame.
     *
     * @param string $web_id The ID of the event frame where the security entry will be created. (required)
     * @param \PIWebAPI\Client\Model\SecurityEntry $security_entry The new security entry definition. The full list of allow and deny rights must be supplied. (required)
     * @param bool $apply_to_children If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return void
     */
    public function eventFrameCreateSecurityEntry($web_id, $security_entry, $apply_to_children = null)
    {
        list($response) = $this->eventFrameCreateSecurityEntryWithHttpInfo($web_id, $security_entry, $apply_to_children);
        return $response;
    }

    /**
     * Operation eventFrameCreateSecurityEntryWithHttpInfo
     *
     * Create a security entry owned by the event frame.
     *
     * @param string $web_id The ID of the event frame where the security entry will be created. (required)
     * @param \PIWebAPI\Client\Model\SecurityEntry $security_entry The new security entry definition. The full list of allow and deny rights must be supplied. (required)
     * @param bool $apply_to_children If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventFrameCreateSecurityEntryWithHttpInfo($web_id, $security_entry, $apply_to_children = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling eventFrameCreateSecurityEntry');
        }
        // verify the required parameter 'security_entry' is set
        if ($security_entry === null) {
            throw new \InvalidArgumentException('Missing the required parameter $security_entry when calling eventFrameCreateSecurityEntry');
        }
        // parse inputs
        $resourcePath = "/eventframes/{webId}/securityentries";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json', 'text/json']);

        // query params
        if ($apply_to_children !== null) {
            $queryParams['applyToChildren'] = $this->apiClient->getSerializer()->toQueryValue($apply_to_children);
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($security_entry)) {
            $_tempBody = $security_entry;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                null,
                '/eventframes/{webId}/securityentries'
            );

            return [null, $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }

            throw $e;
        }
    }

    /**
     * Operation eventFrameDelete
     *
     * Delete an event frame.
     *
     * @param string $web_id The ID of the event frame to delete. (required)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return void
     */
    public function eventFrameDelete($web_id)
    {
        list($response) = $this->eventFrameDeleteWithHttpInfo($web_id);
        return $response;
    }

    /**
     * Operation eventFrameDeleteWithHttpInfo
     *
     * Delete an event frame.
     *
     * @param string $web_id The ID of the event frame to delete. (required)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventFrameDeleteWithHttpInfo($web_id)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling eventFrameDelete');
        }
        // parse inputs
        $resourcePath = "/eventframes/{webId}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'DELETE',
                $queryParams,
                $httpBody,
                $headerParams,
                null,
                '/eventframes/{webId}'
            );

            return [null, $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }

            throw $e;
        }
    }

    /**
     * Operation eventFrameDeleteAnnotation
     *
     * Delete an annotation on an event frame.
     *
     * @param string $id The Annotation identifier of the annotation to be deleted. (required)
     * @param string $web_id The ID of the owner event frame of the annotation to delete. (required)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return void
     */
    public function eventFrameDeleteAnnotation($id, $web_id)
    {
        list($response) = $this->eventFrameDeleteAnnotationWithHttpInfo($id, $web_id);
        return $response;
    }

    /**
     * Operation eventFrameDeleteAnnotationWithHttpInfo
     *
     * Delete an annotation on an event frame.
     *
     * @param string $id The Annotation identifier of the annotation to be deleted. (required)
     * @param string $web_id The ID of the owner event frame of the annotation to delete. (required)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventFrameDeleteAnnotationWithHttpInfo($id, $web_id)
    {
        // verify the required parameter 'id' is set
        if ($id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling eventFrameDeleteAnnotation');
        }
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling eventFrameDeleteAnnotation');
        }
        // parse inputs
        $resourcePath = "/eventframes/{webId}/annotations/{id}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                "{" . "id" . "}",
                $this->apiClient->getSerializer()->toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'DELETE',
                $queryParams,
                $httpBody,
                $headerParams,
                null,
                '/eventframes/{webId}/annotations/{id}'
            );

            return [null, $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }

            throw $e;
        }
    }

    /**
     * Operation eventFrameDeleteSecurityEntry
     *
     * Delete a security entry owned by the event frame.
     *
     * @param string $name The name of the security entry. For every backslash character (\\) in the security entry name, replace with asterisk (*). As an example, use domain*username instead of domain\\username. (required)
     * @param string $web_id The ID of the event frame where the security entry will be deleted. (required)
     * @param bool $apply_to_children If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return void
     */
    public function eventFrameDeleteSecurityEntry($name, $web_id, $apply_to_children = null)
    {
        list($response) = $this->eventFrameDeleteSecurityEntryWithHttpInfo($name, $web_id, $apply_to_children);
        return $response;
    }

    /**
     * Operation eventFrameDeleteSecurityEntryWithHttpInfo
     *
     * Delete a security entry owned by the event frame.
     *
     * @param string $name The name of the security entry. For every backslash character (\\) in the security entry name, replace with asterisk (*). As an example, use domain*username instead of domain\\username. (required)
     * @param string $web_id The ID of the event frame where the security entry will be deleted. (required)
     * @param bool $apply_to_children If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventFrameDeleteSecurityEntryWithHttpInfo($name, $web_id, $apply_to_children = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling eventFrameDeleteSecurityEntry');
        }
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling eventFrameDeleteSecurityEntry');
        }
        // parse inputs
        $resourcePath = "/eventframes/{webId}/securityentries/{name}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($apply_to_children !== null) {
            $queryParams['applyToChildren'] = $this->apiClient->getSerializer()->toQueryValue($apply_to_children);
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                "{" . "name" . "}",
                $this->apiClient->getSerializer()->toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'DELETE',
                $queryParams,
                $httpBody,
                $headerParams,
                null,
                '/eventframes/{webId}/securityentries/{name}'
            );

            return [null, $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }

            throw $e;
        }
    }

    /**
     * Operation eventFrameExecuteSearchByAttribute
     *
     * Execute a \"Search EventFrames By Attribute Value\" operation.
     *
     * @param string $search_id The encoded search Id of the \&quot;Search EventFrames By Attribute Value\&quot; operation. (required)
     * @param bool $can_be_acknowledged Specify the returned event frames&#39; canBeAcknowledged property. The default is no canBeAcknowledged filter. (optional)
     * @param string $end_time The ending time for the search. endTime must be greater than or equal to the startTime. The searchMode parameter will control whether the comparison will be performed against the event frame&#39;s startTime or endTime. The default is &#39;*&#39;. (optional)
     * @param bool $is_acknowledged Specify the returned event frames&#39; isAcknowledged property. The default no isAcknowledged filter. (optional)
     * @param int $max_count The maximum number of objects to be returned per call (page size). The default is 1000. (optional)
     * @param string $name_filter The name query string used for finding event frames. The default is no filter. (optional)
     * @param string $referenced_element_name_filter The name query string which must match the name of a referenced element. The default is no filter. (optional)
     * @param bool $search_full_hierarchy Specifies whether the search should include objects nested further than the immediate children of the search root. The default is &#39;false&#39;. (optional)
     * @param string $search_mode Determines how the startTime and endTime parameters are treated when searching for event frame objects to be included in the returned collection. The default is &#39;Overlapped&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string[] $severity Specify that returned event frames must have this severity. Multiple severity values may be specified with multiple instances of the parameter. The default is no severity filter. (optional)
     * @param string $sort_field The field or property of the object used to sort the returned collection. The default is &#39;Name&#39;. (optional)
     * @param string $sort_order The order that the returned collection is sorted. The default is &#39;Ascending&#39;. (optional)
     * @param int $start_index The starting index (zero based) of the items to be returned. The default is 0. (optional)
     * @param string $start_time The starting time for the search. startTime must be less than or equal to the endTime. The searchMode parameter will control whether the comparison will be performed against the event frame&#39;s startTime or endTime. The default is &#39;*-8h&#39;. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return void
     */
    public function eventFrameExecuteSearchByAttribute($search_id, $can_be_acknowledged = null, $end_time = null, $is_acknowledged = null, $max_count = null, $name_filter = null, $referenced_element_name_filter = null, $search_full_hierarchy = null, $search_mode = null, $selected_fields = null, $severity = null, $sort_field = null, $sort_order = null, $start_index = null, $start_time = null)
    {
        list($response) = $this->eventFrameExecuteSearchByAttributeWithHttpInfo($search_id, $can_be_acknowledged, $end_time, $is_acknowledged, $max_count, $name_filter, $referenced_element_name_filter, $search_full_hierarchy, $search_mode, $selected_fields, $severity, $sort_field, $sort_order, $start_index, $start_time);
        return $response;
    }

    /**
     * Operation eventFrameExecuteSearchByAttributeWithHttpInfo
     *
     * Execute a \"Search EventFrames By Attribute Value\" operation.
     *
     * @param string $search_id The encoded search Id of the \&quot;Search EventFrames By Attribute Value\&quot; operation. (required)
     * @param bool $can_be_acknowledged Specify the returned event frames&#39; canBeAcknowledged property. The default is no canBeAcknowledged filter. (optional)
     * @param string $end_time The ending time for the search. endTime must be greater than or equal to the startTime. The searchMode parameter will control whether the comparison will be performed against the event frame&#39;s startTime or endTime. The default is &#39;*&#39;. (optional)
     * @param bool $is_acknowledged Specify the returned event frames&#39; isAcknowledged property. The default no isAcknowledged filter. (optional)
     * @param int $max_count The maximum number of objects to be returned per call (page size). The default is 1000. (optional)
     * @param string $name_filter The name query string used for finding event frames. The default is no filter. (optional)
     * @param string $referenced_element_name_filter The name query string which must match the name of a referenced element. The default is no filter. (optional)
     * @param bool $search_full_hierarchy Specifies whether the search should include objects nested further than the immediate children of the search root. The default is &#39;false&#39;. (optional)
     * @param string $search_mode Determines how the startTime and endTime parameters are treated when searching for event frame objects to be included in the returned collection. The default is &#39;Overlapped&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string[] $severity Specify that returned event frames must have this severity. Multiple severity values may be specified with multiple instances of the parameter. The default is no severity filter. (optional)
     * @param string $sort_field The field or property of the object used to sort the returned collection. The default is &#39;Name&#39;. (optional)
     * @param string $sort_order The order that the returned collection is sorted. The default is &#39;Ascending&#39;. (optional)
     * @param int $start_index The starting index (zero based) of the items to be returned. The default is 0. (optional)
     * @param string $start_time The starting time for the search. startTime must be less than or equal to the endTime. The searchMode parameter will control whether the comparison will be performed against the event frame&#39;s startTime or endTime. The default is &#39;*-8h&#39;. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventFrameExecuteSearchByAttributeWithHttpInfo($search_id, $can_be_acknowledged = null, $end_time = null, $is_acknowledged = null, $max_count = null, $name_filter = null, $referenced_element_name_filter = null, $search_full_hierarchy = null, $search_mode = null, $selected_fields = null, $severity = null, $sort_field = null, $sort_order = null, $start_index = null, $start_time = null)
    {
        // verify the required parameter 'search_id' is set
        if ($search_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $search_id when calling eventFrameExecuteSearchByAttribute');
        }
        // parse inputs
        $resourcePath = "/eventframes/searchbyattribute/{searchId}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($can_be_acknowledged !== null) {
            $queryParams['canBeAcknowledged'] = $this->apiClient->getSerializer()->toQueryValue($can_be_acknowledged);
        }
        // query params
        if ($end_time !== null) {
            $queryParams['endTime'] = $this->apiClient->getSerializer()->toQueryValue($end_time);
        }
        // query params
        if ($is_acknowledged !== null) {
            $queryParams['isAcknowledged'] = $this->apiClient->getSerializer()->toQueryValue($is_acknowledged);
        }
        // query params
        if ($max_count !== null) {
            $queryParams['maxCount'] = $this->apiClient->getSerializer()->toQueryValue($max_count);
        }
        // query params
        if ($name_filter !== null) {
            $queryParams['nameFilter'] = $this->apiClient->getSerializer()->toQueryValue($name_filter);
        }
        // query params
        if ($referenced_element_name_filter !== null) {
            $queryParams['referencedElementNameFilter'] = $this->apiClient->getSerializer()->toQueryValue($referenced_element_name_filter);
        }
        // query params
        if ($search_full_hierarchy !== null) {
            $queryParams['searchFullHierarchy'] = $this->apiClient->getSerializer()->toQueryValue($search_full_hierarchy);
        }
        // query params
        if ($search_mode !== null) {
            $queryParams['searchMode'] = $this->apiClient->getSerializer()->toQueryValue($search_mode);
        }
        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // query params
        if (is_array($severity)) {
            $severity = $this->apiClient->getSerializer()->serializeCollection($severity, 'multi', true);
        }
        if ($severity !== null) {
            $queryParams['severity'] = $this->apiClient->getSerializer()->toQueryValue($severity);
        }
        // query params
        if ($sort_field !== null) {
            $queryParams['sortField'] = $this->apiClient->getSerializer()->toQueryValue($sort_field);
        }
        // query params
        if ($sort_order !== null) {
            $queryParams['sortOrder'] = $this->apiClient->getSerializer()->toQueryValue($sort_order);
        }
        // query params
        if ($start_index !== null) {
            $queryParams['startIndex'] = $this->apiClient->getSerializer()->toQueryValue($start_index);
        }
        // query params
        if ($start_time !== null) {
            $queryParams['startTime'] = $this->apiClient->getSerializer()->toQueryValue($start_time);
        }
        // path params
        if ($search_id !== null) {
            $resourcePath = str_replace(
                "{" . "searchId" . "}",
                $this->apiClient->getSerializer()->toPathValue($search_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                null,
                '/eventframes/searchbyattribute/{searchId}'
            );

            return [null, $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation eventFrameFindEventFrameAttributes
     *
     * Retrieves a list of event frame attributes matching the specified filters from the specified event frame.
     *
     * @param string $web_id The ID of the event frame to use as the root of the search. (required)
     * @param string $attribute_category Specify that returned attributes must have this category. The default is no filter. (optional)
     * @param string $attribute_description_filter The attribute description filter string used for finding objects. Only the first 440 characters of the description will be searched. For Asset Servers older than 2.7, a 400 status code (Bad Request) will be returned if this parameter is specified. The default is no filter. (optional)
     * @param string $attribute_name_filter The attribute name filter string used for finding objects. The default is no filter. (optional)
     * @param string $attribute_type Specify that returned attributes&#39; value type must be this value type. The default is no filter. (optional)
     * @param string $end_time A string representing the latest ending time for the event frames to be matched. The endTime must be greater than or equal to the startTime. The default is &#39;*&#39;. (optional)
     * @param string $event_frame_category Specify that the owner of the returned attributes must have this category. The default is no filter. (optional)
     * @param string $event_frame_description_filter The event frame description filter string used for finding objects. Only the first 440 characters of the description will be searched. For Asset Servers older than 2.7, a 400 status code (Bad Request) will be returned if this parameter is specified. The default is no filter. (optional)
     * @param string $event_frame_name_filter The event frame name filter string used for finding objects. The default is no filter. (optional)
     * @param string $event_frame_template Specify that the owner of the returned attributes must have this template or a template derived from this template. The default is no filter. (optional)
     * @param int $max_count The maximum number of objects to be returned (the page size). The default is 1000. (optional)
     * @param string $referenced_element_name_filter The name query string which must match the name of a referenced element. The default is no filter. (optional)
     * @param bool $search_full_hierarchy Specifies if the search should include objects nested further than immediate children of the given resource. The default is &#39;false&#39;. (optional)
     * @param string $search_mode Determines how the startTime and endTime parameters are treated when searching for event frames.     The default is &#39;Overlapped&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string $sort_field The field or property of the object used to sort the returned collection. The default is &#39;Name&#39;. (optional)
     * @param string $sort_order The order that the returned collection is sorted. The default is &#39;Ascending&#39;. (optional)
     * @param int $start_index The starting index (zero based) of the items to be returned. The default is 0. (optional)
     * @param string $start_time A string representing the earliest starting time for the event frames to be matched. startTime must be less than or equal to the endTime. The default is &#39;*-8h&#39;. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\ItemsAttribute
     */
    public function eventFrameFindEventFrameAttributes($web_id, $attribute_category = null, $attribute_description_filter = null, $attribute_name_filter = null, $attribute_type = null, $end_time = null, $event_frame_category = null, $event_frame_description_filter = null, $event_frame_name_filter = null, $event_frame_template = null, $max_count = null, $referenced_element_name_filter = null, $search_full_hierarchy = null, $search_mode = null, $selected_fields = null, $sort_field = null, $sort_order = null, $start_index = null, $start_time = null)
    {
        list($response) = $this->eventFrameFindEventFrameAttributesWithHttpInfo($web_id, $attribute_category, $attribute_description_filter, $attribute_name_filter, $attribute_type, $end_time, $event_frame_category, $event_frame_description_filter, $event_frame_name_filter, $event_frame_template, $max_count, $referenced_element_name_filter, $search_full_hierarchy, $search_mode, $selected_fields, $sort_field, $sort_order, $start_index, $start_time);
        return $response;
    }

    /**
     * Operation eventFrameFindEventFrameAttributesWithHttpInfo
     *
     * Retrieves a list of event frame attributes matching the specified filters from the specified event frame.
     *
     * @param string $web_id The ID of the event frame to use as the root of the search. (required)
     * @param string $attribute_category Specify that returned attributes must have this category. The default is no filter. (optional)
     * @param string $attribute_description_filter The attribute description filter string used for finding objects. Only the first 440 characters of the description will be searched. For Asset Servers older than 2.7, a 400 status code (Bad Request) will be returned if this parameter is specified. The default is no filter. (optional)
     * @param string $attribute_name_filter The attribute name filter string used for finding objects. The default is no filter. (optional)
     * @param string $attribute_type Specify that returned attributes&#39; value type must be this value type. The default is no filter. (optional)
     * @param string $end_time A string representing the latest ending time for the event frames to be matched. The endTime must be greater than or equal to the startTime. The default is &#39;*&#39;. (optional)
     * @param string $event_frame_category Specify that the owner of the returned attributes must have this category. The default is no filter. (optional)
     * @param string $event_frame_description_filter The event frame description filter string used for finding objects. Only the first 440 characters of the description will be searched. For Asset Servers older than 2.7, a 400 status code (Bad Request) will be returned if this parameter is specified. The default is no filter. (optional)
     * @param string $event_frame_name_filter The event frame name filter string used for finding objects. The default is no filter. (optional)
     * @param string $event_frame_template Specify that the owner of the returned attributes must have this template or a template derived from this template. The default is no filter. (optional)
     * @param int $max_count The maximum number of objects to be returned (the page size). The default is 1000. (optional)
     * @param string $referenced_element_name_filter The name query string which must match the name of a referenced element. The default is no filter. (optional)
     * @param bool $search_full_hierarchy Specifies if the search should include objects nested further than immediate children of the given resource. The default is &#39;false&#39;. (optional)
     * @param string $search_mode Determines how the startTime and endTime parameters are treated when searching for event frames.     The default is &#39;Overlapped&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string $sort_field The field or property of the object used to sort the returned collection. The default is &#39;Name&#39;. (optional)
     * @param string $sort_order The order that the returned collection is sorted. The default is &#39;Ascending&#39;. (optional)
     * @param int $start_index The starting index (zero based) of the items to be returned. The default is 0. (optional)
     * @param string $start_time A string representing the earliest starting time for the event frames to be matched. startTime must be less than or equal to the endTime. The default is &#39;*-8h&#39;. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\ItemsAttribute, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventFrameFindEventFrameAttributesWithHttpInfo($web_id, $attribute_category = null, $attribute_description_filter = null, $attribute_name_filter = null, $attribute_type = null, $end_time = null, $event_frame_category = null, $event_frame_description_filter = null, $event_frame_name_filter = null, $event_frame_template = null, $max_count = null, $referenced_element_name_filter = null, $search_full_hierarchy = null, $search_mode = null, $selected_fields = null, $sort_field = null, $sort_order = null, $start_index = null, $start_time = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling eventFrameFindEventFrameAttributes');
        }
        // parse inputs
        $resourcePath = "/eventframes/{webId}/eventframeattributes";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($attribute_category !== null) {
            $queryParams['attributeCategory'] = $this->apiClient->getSerializer()->toQueryValue($attribute_category);
        }
        // query params
        if ($attribute_description_filter !== null) {
            $queryParams['attributeDescriptionFilter'] = $this->apiClient->getSerializer()->toQueryValue($attribute_description_filter);
        }
        // query params
        if ($attribute_name_filter !== null) {
            $queryParams['attributeNameFilter'] = $this->apiClient->getSerializer()->toQueryValue($attribute_name_filter);
        }
        // query params
        if ($attribute_type !== null) {
            $queryParams['attributeType'] = $this->apiClient->getSerializer()->toQueryValue($attribute_type);
        }
        // query params
        if ($end_time !== null) {
            $queryParams['endTime'] = $this->apiClient->getSerializer()->toQueryValue($end_time);
        }
        // query params
        if ($event_frame_category !== null) {
            $queryParams['eventFrameCategory'] = $this->apiClient->getSerializer()->toQueryValue($event_frame_category);
        }
        // query params
        if ($event_frame_description_filter !== null) {
            $queryParams['eventFrameDescriptionFilter'] = $this->apiClient->getSerializer()->toQueryValue($event_frame_description_filter);
        }
        // query params
        if ($event_frame_name_filter !== null) {
            $queryParams['eventFrameNameFilter'] = $this->apiClient->getSerializer()->toQueryValue($event_frame_name_filter);
        }
        // query params
        if ($event_frame_template !== null) {
            $queryParams['eventFrameTemplate'] = $this->apiClient->getSerializer()->toQueryValue($event_frame_template);
        }
        // query params
        if ($max_count !== null) {
            $queryParams['maxCount'] = $this->apiClient->getSerializer()->toQueryValue($max_count);
        }
        // query params
        if ($referenced_element_name_filter !== null) {
            $queryParams['referencedElementNameFilter'] = $this->apiClient->getSerializer()->toQueryValue($referenced_element_name_filter);
        }
        // query params
        if ($search_full_hierarchy !== null) {
            $queryParams['searchFullHierarchy'] = $this->apiClient->getSerializer()->toQueryValue($search_full_hierarchy);
        }
        // query params
        if ($search_mode !== null) {
            $queryParams['searchMode'] = $this->apiClient->getSerializer()->toQueryValue($search_mode);
        }
        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // query params
        if ($sort_field !== null) {
            $queryParams['sortField'] = $this->apiClient->getSerializer()->toQueryValue($sort_field);
        }
        // query params
        if ($sort_order !== null) {
            $queryParams['sortOrder'] = $this->apiClient->getSerializer()->toQueryValue($sort_order);
        }
        // query params
        if ($start_index !== null) {
            $queryParams['startIndex'] = $this->apiClient->getSerializer()->toQueryValue($start_index);
        }
        // query params
        if ($start_time !== null) {
            $queryParams['startTime'] = $this->apiClient->getSerializer()->toQueryValue($start_time);
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\ItemsAttribute',
                '/eventframes/{webId}/eventframeattributes'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\ItemsAttribute', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsAttribute', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation eventFrameGet
     *
     * Retrieve an event frame.
     *
     * @param string $web_id The ID of the event frame. (required)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\EventFrame
     */
    public function eventFrameGet($web_id, $selected_fields = null)
    {
        list($response) = $this->eventFrameGetWithHttpInfo($web_id, $selected_fields);
        return $response;
    }

    /**
     * Operation eventFrameGetWithHttpInfo
     *
     * Retrieve an event frame.
     *
     * @param string $web_id The ID of the event frame. (required)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\EventFrame, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventFrameGetWithHttpInfo($web_id, $selected_fields = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling eventFrameGet');
        }
        // parse inputs
        $resourcePath = "/eventframes/{webId}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\EventFrame',
                '/eventframes/{webId}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\EventFrame', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\EventFrame', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation eventFrameGetAnnotationById
     *
     * Get a specific annotation on an event frame.
     *
     * @param string $id The Annotation identifier of the specific annotation. (required)
     * @param string $web_id The ID of the owner event frame. (required)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\Annotation
     */
    public function eventFrameGetAnnotationById($id, $web_id, $selected_fields = null)
    {
        list($response) = $this->eventFrameGetAnnotationByIdWithHttpInfo($id, $web_id, $selected_fields);
        return $response;
    }

    /**
     * Operation eventFrameGetAnnotationByIdWithHttpInfo
     *
     * Get a specific annotation on an event frame.
     *
     * @param string $id The Annotation identifier of the specific annotation. (required)
     * @param string $web_id The ID of the owner event frame. (required)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\Annotation, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventFrameGetAnnotationByIdWithHttpInfo($id, $web_id, $selected_fields = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling eventFrameGetAnnotationById');
        }
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling eventFrameGetAnnotationById');
        }
        // parse inputs
        $resourcePath = "/eventframes/{webId}/annotations/{id}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                "{" . "id" . "}",
                $this->apiClient->getSerializer()->toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\Annotation',
                '/eventframes/{webId}/annotations/{id}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\Annotation', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Annotation', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation eventFrameGetAnnotations
     *
     * Get an event frame's annotations.
     *
     * @param string $web_id The ID of the owner event frame. (required)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\ItemsAnnotation
     */
    public function eventFrameGetAnnotations($web_id, $selected_fields = null)
    {
        list($response) = $this->eventFrameGetAnnotationsWithHttpInfo($web_id, $selected_fields);
        return $response;
    }

    /**
     * Operation eventFrameGetAnnotationsWithHttpInfo
     *
     * Get an event frame's annotations.
     *
     * @param string $web_id The ID of the owner event frame. (required)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\ItemsAnnotation, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventFrameGetAnnotationsWithHttpInfo($web_id, $selected_fields = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling eventFrameGetAnnotations');
        }
        // parse inputs
        $resourcePath = "/eventframes/{webId}/annotations";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\ItemsAnnotation',
                '/eventframes/{webId}/annotations'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\ItemsAnnotation', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsAnnotation', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation eventFrameGetAttributes
     *
     * Get the attributes of the specified event frame.
     *
     * @param string $web_id The ID of the event frame. (required)
     * @param string $category_name Specify that returned attributes must have this category. The default is no category filter. (optional)
     * @param int $max_count The maximum number of objects to be returned per call (page size). The default is 1000. (optional)
     * @param string $name_filter The name query string used for finding attributes. The default is no filter. (optional)
     * @param bool $search_full_hierarchy Specifies if the search should include attributes nested further than the immediate attributes of the searchRoot. The default is &#39;false&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param bool $show_excluded Specified if the search should include attributes with the Excluded property set. The default is &#39;false&#39;. (optional)
     * @param bool $show_hidden Specified if the search should include attributes with the Hidden property set. The default is &#39;false&#39;. (optional)
     * @param string $sort_field The field or property of the object used to sort the returned collection. The default is &#39;Name&#39;. (optional)
     * @param string $sort_order The order that the returned collection is sorted. The default is &#39;Ascending&#39;. (optional)
     * @param int $start_index The starting index (zero based) of the items to be returned. The default is 0. (optional)
     * @param string $template_name Specify that returned attributes must be members of this template. The default is no template filter. (optional)
     * @param string $value_type Specify that returned attributes&#39; value type must be the given value type. The default is no value type filter. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\ItemsAttribute
     */
    public function eventFrameGetAttributes($web_id, $category_name = null, $max_count = null, $name_filter = null, $search_full_hierarchy = null, $selected_fields = null, $show_excluded = null, $show_hidden = null, $sort_field = null, $sort_order = null, $start_index = null, $template_name = null, $value_type = null)
    {
        list($response) = $this->eventFrameGetAttributesWithHttpInfo($web_id, $category_name, $max_count, $name_filter, $search_full_hierarchy, $selected_fields, $show_excluded, $show_hidden, $sort_field, $sort_order, $start_index, $template_name, $value_type);
        return $response;
    }

    /**
     * Operation eventFrameGetAttributesWithHttpInfo
     *
     * Get the attributes of the specified event frame.
     *
     * @param string $web_id The ID of the event frame. (required)
     * @param string $category_name Specify that returned attributes must have this category. The default is no category filter. (optional)
     * @param int $max_count The maximum number of objects to be returned per call (page size). The default is 1000. (optional)
     * @param string $name_filter The name query string used for finding attributes. The default is no filter. (optional)
     * @param bool $search_full_hierarchy Specifies if the search should include attributes nested further than the immediate attributes of the searchRoot. The default is &#39;false&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param bool $show_excluded Specified if the search should include attributes with the Excluded property set. The default is &#39;false&#39;. (optional)
     * @param bool $show_hidden Specified if the search should include attributes with the Hidden property set. The default is &#39;false&#39;. (optional)
     * @param string $sort_field The field or property of the object used to sort the returned collection. The default is &#39;Name&#39;. (optional)
     * @param string $sort_order The order that the returned collection is sorted. The default is &#39;Ascending&#39;. (optional)
     * @param int $start_index The starting index (zero based) of the items to be returned. The default is 0. (optional)
     * @param string $template_name Specify that returned attributes must be members of this template. The default is no template filter. (optional)
     * @param string $value_type Specify that returned attributes&#39; value type must be the given value type. The default is no value type filter. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\ItemsAttribute, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventFrameGetAttributesWithHttpInfo($web_id, $category_name = null, $max_count = null, $name_filter = null, $search_full_hierarchy = null, $selected_fields = null, $show_excluded = null, $show_hidden = null, $sort_field = null, $sort_order = null, $start_index = null, $template_name = null, $value_type = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling eventFrameGetAttributes');
        }
        // parse inputs
        $resourcePath = "/eventframes/{webId}/attributes";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($category_name !== null) {
            $queryParams['categoryName'] = $this->apiClient->getSerializer()->toQueryValue($category_name);
        }
        // query params
        if ($max_count !== null) {
            $queryParams['maxCount'] = $this->apiClient->getSerializer()->toQueryValue($max_count);
        }
        // query params
        if ($name_filter !== null) {
            $queryParams['nameFilter'] = $this->apiClient->getSerializer()->toQueryValue($name_filter);
        }
        // query params
        if ($search_full_hierarchy !== null) {
            $queryParams['searchFullHierarchy'] = $this->apiClient->getSerializer()->toQueryValue($search_full_hierarchy);
        }
        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // query params
        if ($show_excluded !== null) {
            $queryParams['showExcluded'] = $this->apiClient->getSerializer()->toQueryValue($show_excluded);
        }
        // query params
        if ($show_hidden !== null) {
            $queryParams['showHidden'] = $this->apiClient->getSerializer()->toQueryValue($show_hidden);
        }
        // query params
        if ($sort_field !== null) {
            $queryParams['sortField'] = $this->apiClient->getSerializer()->toQueryValue($sort_field);
        }
        // query params
        if ($sort_order !== null) {
            $queryParams['sortOrder'] = $this->apiClient->getSerializer()->toQueryValue($sort_order);
        }
        // query params
        if ($start_index !== null) {
            $queryParams['startIndex'] = $this->apiClient->getSerializer()->toQueryValue($start_index);
        }
        // query params
        if ($template_name !== null) {
            $queryParams['templateName'] = $this->apiClient->getSerializer()->toQueryValue($template_name);
        }
        // query params
        if ($value_type !== null) {
            $queryParams['valueType'] = $this->apiClient->getSerializer()->toQueryValue($value_type);
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\ItemsAttribute',
                '/eventframes/{webId}/attributes'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\ItemsAttribute', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsAttribute', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation eventFrameGetByPath
     *
     * Retrieve an event frame by path.
     *
     * @param string $path The path to the event frame. (required)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\EventFrame
     */
    public function eventFrameGetByPath($path, $selected_fields = null)
    {
        list($response) = $this->eventFrameGetByPathWithHttpInfo($path, $selected_fields);
        return $response;
    }

    /**
     * Operation eventFrameGetByPathWithHttpInfo
     *
     * Retrieve an event frame by path.
     *
     * @param string $path The path to the event frame. (required)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\EventFrame, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventFrameGetByPathWithHttpInfo($path, $selected_fields = null)
    {
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling eventFrameGetByPath');
        }
        // parse inputs
        $resourcePath = "/eventframes";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($path !== null) {
            $queryParams['path'] = $this->apiClient->getSerializer()->toQueryValue($path);
        }
        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\EventFrame',
                '/eventframes'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\EventFrame', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\EventFrame', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation eventFrameGetCategories
     *
     * Get an event frame's categories.
     *
     * @param string $web_id The ID of the event frame. (required)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\ItemsElementCategory
     */
    public function eventFrameGetCategories($web_id, $selected_fields = null)
    {
        list($response) = $this->eventFrameGetCategoriesWithHttpInfo($web_id, $selected_fields);
        return $response;
    }

    /**
     * Operation eventFrameGetCategoriesWithHttpInfo
     *
     * Get an event frame's categories.
     *
     * @param string $web_id The ID of the event frame. (required)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\ItemsElementCategory, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventFrameGetCategoriesWithHttpInfo($web_id, $selected_fields = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling eventFrameGetCategories');
        }
        // parse inputs
        $resourcePath = "/eventframes/{webId}/categories";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\ItemsElementCategory',
                '/eventframes/{webId}/categories'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\ItemsElementCategory', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsElementCategory', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation eventFrameGetEventFrames
     *
     * Retrieve event frames based on the specified conditions. By default, returns all children of the specified root event frame with a start time in the past 8 hours.
     *
     * @param string $web_id The ID of the event frame to use as the root of the search. (required)
     * @param bool $can_be_acknowledged Specify the returned event frames&#39; canBeAcknowledged property. The default is no canBeAcknowledged filter. (optional)
     * @param string $category_name Specify that returned event frames must have this category. The default is no category filter. (optional)
     * @param string $end_time The ending time for the search. The endTime must be greater than or equal to the startTime. The searchMode parameter will control whether the comparison will be performed against the event frame&#39;s startTime or endTime. The default is &#39;*&#39; if searchMode is not one of the &#39;Backward*&#39; or &#39;Forward*&#39; values. (optional)
     * @param bool $is_acknowledged Specify the returned event frames&#39; isAcknowledged property. The default no isAcknowledged filter. (optional)
     * @param int $max_count The maximum number of objects to be returned per call (page size). The default is 1000. (optional)
     * @param string $name_filter The name query string used for finding event frames. The default is no filter. (optional)
     * @param string $referenced_element_name_filter The name query string which must match the name of a referenced element. The default is no filter. (optional)
     * @param string $referenced_element_template_name Specify that returned event frames must have an element in the event frame&#39;s referenced elements collection that derives from the template. Specify this parameter by name. (optional)
     * @param bool $search_full_hierarchy Specifies whether the search should include objects nested further than the immediate children of the search root. The default is &#39;false&#39;. (optional)
     * @param string $search_mode Determines how the startTime and endTime parameters are treated when searching for event frame objects to be included in the returned collection. If this parameter is one of the &#39;Backward*&#39; or &#39;Forward*&#39; values, none of endTime, sortField, or sortOrder may be specified. The default is &#39;Overlapped&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string[] $severity Specify that returned event frames must have this severity. Multiple severity values may be specified with multiple instances of the parameter. The default is no severity filter. (optional)
     * @param string $sort_field The field or property of the object used to sort the returned collection. The default is &#39;Name&#39; if searchMode is not one of the &#39;Backward*&#39; or &#39;Forward*&#39; values. (optional)
     * @param string $sort_order The order that the returned collection is sorted. The default is &#39;Ascending&#39; if searchMode is not one of the &#39;Backward*&#39; or &#39;Forward*&#39; values. (optional)
     * @param int $start_index The starting index (zero based) of the items to be returned. The default is 0. (optional)
     * @param string $start_time The starting time for the search. startTime must be less than or equal to the endTime. The searchMode parameter will control whether the comparison will be performed against the event frame&#39;s startTime or endTime. The default is &#39;*-8h&#39;. (optional)
     * @param string $template_name Specify that returned event frames must have this template or a template derived from this template. The default is no template filter. Specify this parameter by name. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\ItemsEventFrame
     */
    public function eventFrameGetEventFrames($web_id, $can_be_acknowledged = null, $category_name = null, $end_time = null, $is_acknowledged = null, $max_count = null, $name_filter = null, $referenced_element_name_filter = null, $referenced_element_template_name = null, $search_full_hierarchy = null, $search_mode = null, $selected_fields = null, $severity = null, $sort_field = null, $sort_order = null, $start_index = null, $start_time = null, $template_name = null)
    {
        list($response) = $this->eventFrameGetEventFramesWithHttpInfo($web_id, $can_be_acknowledged, $category_name, $end_time, $is_acknowledged, $max_count, $name_filter, $referenced_element_name_filter, $referenced_element_template_name, $search_full_hierarchy, $search_mode, $selected_fields, $severity, $sort_field, $sort_order, $start_index, $start_time, $template_name);
        return $response;
    }

    /**
     * Operation eventFrameGetEventFramesWithHttpInfo
     *
     * Retrieve event frames based on the specified conditions. By default, returns all children of the specified root event frame with a start time in the past 8 hours.
     *
     * @param string $web_id The ID of the event frame to use as the root of the search. (required)
     * @param bool $can_be_acknowledged Specify the returned event frames&#39; canBeAcknowledged property. The default is no canBeAcknowledged filter. (optional)
     * @param string $category_name Specify that returned event frames must have this category. The default is no category filter. (optional)
     * @param string $end_time The ending time for the search. The endTime must be greater than or equal to the startTime. The searchMode parameter will control whether the comparison will be performed against the event frame&#39;s startTime or endTime. The default is &#39;*&#39; if searchMode is not one of the &#39;Backward*&#39; or &#39;Forward*&#39; values. (optional)
     * @param bool $is_acknowledged Specify the returned event frames&#39; isAcknowledged property. The default no isAcknowledged filter. (optional)
     * @param int $max_count The maximum number of objects to be returned per call (page size). The default is 1000. (optional)
     * @param string $name_filter The name query string used for finding event frames. The default is no filter. (optional)
     * @param string $referenced_element_name_filter The name query string which must match the name of a referenced element. The default is no filter. (optional)
     * @param string $referenced_element_template_name Specify that returned event frames must have an element in the event frame&#39;s referenced elements collection that derives from the template. Specify this parameter by name. (optional)
     * @param bool $search_full_hierarchy Specifies whether the search should include objects nested further than the immediate children of the search root. The default is &#39;false&#39;. (optional)
     * @param string $search_mode Determines how the startTime and endTime parameters are treated when searching for event frame objects to be included in the returned collection. If this parameter is one of the &#39;Backward*&#39; or &#39;Forward*&#39; values, none of endTime, sortField, or sortOrder may be specified. The default is &#39;Overlapped&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string[] $severity Specify that returned event frames must have this severity. Multiple severity values may be specified with multiple instances of the parameter. The default is no severity filter. (optional)
     * @param string $sort_field The field or property of the object used to sort the returned collection. The default is &#39;Name&#39; if searchMode is not one of the &#39;Backward*&#39; or &#39;Forward*&#39; values. (optional)
     * @param string $sort_order The order that the returned collection is sorted. The default is &#39;Ascending&#39; if searchMode is not one of the &#39;Backward*&#39; or &#39;Forward*&#39; values. (optional)
     * @param int $start_index The starting index (zero based) of the items to be returned. The default is 0. (optional)
     * @param string $start_time The starting time for the search. startTime must be less than or equal to the endTime. The searchMode parameter will control whether the comparison will be performed against the event frame&#39;s startTime or endTime. The default is &#39;*-8h&#39;. (optional)
     * @param string $template_name Specify that returned event frames must have this template or a template derived from this template. The default is no template filter. Specify this parameter by name. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\ItemsEventFrame, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventFrameGetEventFramesWithHttpInfo($web_id, $can_be_acknowledged = null, $category_name = null, $end_time = null, $is_acknowledged = null, $max_count = null, $name_filter = null, $referenced_element_name_filter = null, $referenced_element_template_name = null, $search_full_hierarchy = null, $search_mode = null, $selected_fields = null, $severity = null, $sort_field = null, $sort_order = null, $start_index = null, $start_time = null, $template_name = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling eventFrameGetEventFrames');
        }
        // parse inputs
        $resourcePath = "/eventframes/{webId}/eventframes";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($can_be_acknowledged !== null) {
            $queryParams['canBeAcknowledged'] = $this->apiClient->getSerializer()->toQueryValue($can_be_acknowledged);
        }
        // query params
        if ($category_name !== null) {
            $queryParams['categoryName'] = $this->apiClient->getSerializer()->toQueryValue($category_name);
        }
        // query params
        if ($end_time !== null) {
            $queryParams['endTime'] = $this->apiClient->getSerializer()->toQueryValue($end_time);
        }
        // query params
        if ($is_acknowledged !== null) {
            $queryParams['isAcknowledged'] = $this->apiClient->getSerializer()->toQueryValue($is_acknowledged);
        }
        // query params
        if ($max_count !== null) {
            $queryParams['maxCount'] = $this->apiClient->getSerializer()->toQueryValue($max_count);
        }
        // query params
        if ($name_filter !== null) {
            $queryParams['nameFilter'] = $this->apiClient->getSerializer()->toQueryValue($name_filter);
        }
        // query params
        if ($referenced_element_name_filter !== null) {
            $queryParams['referencedElementNameFilter'] = $this->apiClient->getSerializer()->toQueryValue($referenced_element_name_filter);
        }
        // query params
        if ($referenced_element_template_name !== null) {
            $queryParams['referencedElementTemplateName'] = $this->apiClient->getSerializer()->toQueryValue($referenced_element_template_name);
        }
        // query params
        if ($search_full_hierarchy !== null) {
            $queryParams['searchFullHierarchy'] = $this->apiClient->getSerializer()->toQueryValue($search_full_hierarchy);
        }
        // query params
        if ($search_mode !== null) {
            $queryParams['searchMode'] = $this->apiClient->getSerializer()->toQueryValue($search_mode);
        }
        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // query params
        if (is_array($severity)) {
            $severity = $this->apiClient->getSerializer()->serializeCollection($severity, 'multi', true);
        }
        if ($severity !== null) {
            $queryParams['severity'] = $this->apiClient->getSerializer()->toQueryValue($severity);
        }
        // query params
        if ($sort_field !== null) {
            $queryParams['sortField'] = $this->apiClient->getSerializer()->toQueryValue($sort_field);
        }
        // query params
        if ($sort_order !== null) {
            $queryParams['sortOrder'] = $this->apiClient->getSerializer()->toQueryValue($sort_order);
        }
        // query params
        if ($start_index !== null) {
            $queryParams['startIndex'] = $this->apiClient->getSerializer()->toQueryValue($start_index);
        }
        // query params
        if ($start_time !== null) {
            $queryParams['startTime'] = $this->apiClient->getSerializer()->toQueryValue($start_time);
        }
        // query params
        if ($template_name !== null) {
            $queryParams['templateName'] = $this->apiClient->getSerializer()->toQueryValue($template_name);
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\ItemsEventFrame',
                '/eventframes/{webId}/eventframes'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\ItemsEventFrame', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsEventFrame', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation eventFrameGetMultiple
     *
     * Retrieve multiple event frames by web ids or paths.
     *
     * @param bool $as_parallel Specifies if the retrieval processes should be run in parallel on the server. This may improve the response time for large amounts of requested attributes. The default is &#39;false&#39;. (optional)
     * @param string $include_mode The include mode for the return list. The default is &#39;All&#39;. (optional)
     * @param string[] $path The path of an event frame. Multiple event frames may be specified with multiple instances of the parameter. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string[] $web_id The ID of an event frame. Multiple event frames may be specified with multiple instances of the parameter. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\ItemsItemEventFrame
     */
    public function eventFrameGetMultiple($as_parallel = null, $include_mode = null, $path = null, $selected_fields = null, $web_id = null)
    {
        list($response) = $this->eventFrameGetMultipleWithHttpInfo($as_parallel, $include_mode, $path, $selected_fields, $web_id);
        return $response;
    }

    /**
     * Operation eventFrameGetMultipleWithHttpInfo
     *
     * Retrieve multiple event frames by web ids or paths.
     *
     * @param bool $as_parallel Specifies if the retrieval processes should be run in parallel on the server. This may improve the response time for large amounts of requested attributes. The default is &#39;false&#39;. (optional)
     * @param string $include_mode The include mode for the return list. The default is &#39;All&#39;. (optional)
     * @param string[] $path The path of an event frame. Multiple event frames may be specified with multiple instances of the parameter. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string[] $web_id The ID of an event frame. Multiple event frames may be specified with multiple instances of the parameter. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\ItemsItemEventFrame, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventFrameGetMultipleWithHttpInfo($as_parallel = null, $include_mode = null, $path = null, $selected_fields = null, $web_id = null)
    {
        // parse inputs
        $resourcePath = "/eventframes/multiple";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($as_parallel !== null) {
            $queryParams['asParallel'] = $this->apiClient->getSerializer()->toQueryValue($as_parallel);
        }
        // query params
        if ($include_mode !== null) {
            $queryParams['includeMode'] = $this->apiClient->getSerializer()->toQueryValue($include_mode);
        }
        // query params
        if (is_array($path)) {
            $path = $this->apiClient->getSerializer()->serializeCollection($path, 'multi', true);
        }
        if ($path !== null) {
            $queryParams['path'] = $this->apiClient->getSerializer()->toQueryValue($path);
        }
        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // query params
        if (is_array($web_id)) {
            $web_id = $this->apiClient->getSerializer()->serializeCollection($web_id, 'multi', true);
        }
        if ($web_id !== null) {
            $queryParams['webId'] = $this->apiClient->getSerializer()->toQueryValue($web_id);
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\ItemsItemEventFrame',
                '/eventframes/multiple'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\ItemsItemEventFrame', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsItemEventFrame', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 207:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsItemEventFrame', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation eventFrameGetReferencedElements
     *
     * Retrieve the event frame's referenced elements.
     *
     * @param string $web_id The ID of the event frame whose referenced elements should be retrieved. (required)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\ItemsElement
     */
    public function eventFrameGetReferencedElements($web_id, $selected_fields = null)
    {
        list($response) = $this->eventFrameGetReferencedElementsWithHttpInfo($web_id, $selected_fields);
        return $response;
    }

    /**
     * Operation eventFrameGetReferencedElementsWithHttpInfo
     *
     * Retrieve the event frame's referenced elements.
     *
     * @param string $web_id The ID of the event frame whose referenced elements should be retrieved. (required)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\ItemsElement, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventFrameGetReferencedElementsWithHttpInfo($web_id, $selected_fields = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling eventFrameGetReferencedElements');
        }
        // parse inputs
        $resourcePath = "/eventframes/{webId}/referencedelements";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\ItemsElement',
                '/eventframes/{webId}/referencedelements'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\ItemsElement', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsElement', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation eventFrameGetSecurity
     *
     * Get the security information of the specified security item associated with the event frame for a specified user.
     *
     * @param string $web_id The ID of the event frame for the security to be checked. (required)
     * @param string[] $user_identity The user identity for the security information to be checked. Multiple security identities may be specified with multiple instances of the parameter. If the parameter is not specified, only the current user&#39;s security rights will be returned. (required)
     * @param bool $force_refresh Indicates if the security cache should be refreshed before getting security information. The default is &#39;false&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\ItemsSecurityRights
     */
    public function eventFrameGetSecurity($web_id, $user_identity, $force_refresh = null, $selected_fields = null)
    {
        list($response) = $this->eventFrameGetSecurityWithHttpInfo($web_id, $user_identity, $force_refresh, $selected_fields);
        return $response;
    }

    /**
     * Operation eventFrameGetSecurityWithHttpInfo
     *
     * Get the security information of the specified security item associated with the event frame for a specified user.
     *
     * @param string $web_id The ID of the event frame for the security to be checked. (required)
     * @param string[] $user_identity The user identity for the security information to be checked. Multiple security identities may be specified with multiple instances of the parameter. If the parameter is not specified, only the current user&#39;s security rights will be returned. (required)
     * @param bool $force_refresh Indicates if the security cache should be refreshed before getting security information. The default is &#39;false&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\ItemsSecurityRights, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventFrameGetSecurityWithHttpInfo($web_id, $user_identity, $force_refresh = null, $selected_fields = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling eventFrameGetSecurity');
        }
        // verify the required parameter 'user_identity' is set
        if ($user_identity === null) {
            throw new \InvalidArgumentException('Missing the required parameter $user_identity when calling eventFrameGetSecurity');
        }
        // parse inputs
        $resourcePath = "/eventframes/{webId}/security";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if (is_array($user_identity)) {
            $user_identity = $this->apiClient->getSerializer()->serializeCollection($user_identity, 'multi', true);
        }
        if ($user_identity !== null) {
            $queryParams['userIdentity'] = $this->apiClient->getSerializer()->toQueryValue($user_identity);
        }
        // query params
        if ($force_refresh !== null) {
            $queryParams['forceRefresh'] = $this->apiClient->getSerializer()->toQueryValue($force_refresh);
        }
        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\ItemsSecurityRights',
                '/eventframes/{webId}/security'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\ItemsSecurityRights', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsSecurityRights', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 502:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation eventFrameGetSecurityEntries
     *
     * Retrieve the security entries associated with the event frame based on the specified criteria. By default, all security entries for this event frame are returned.
     *
     * @param string $web_id The ID of the event frame. (required)
     * @param string $name_filter The name query string used for filtering security entries. The default is no filter. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\ItemsSecurityEntry
     */
    public function eventFrameGetSecurityEntries($web_id, $name_filter = null, $selected_fields = null)
    {
        list($response) = $this->eventFrameGetSecurityEntriesWithHttpInfo($web_id, $name_filter, $selected_fields);
        return $response;
    }

    /**
     * Operation eventFrameGetSecurityEntriesWithHttpInfo
     *
     * Retrieve the security entries associated with the event frame based on the specified criteria. By default, all security entries for this event frame are returned.
     *
     * @param string $web_id The ID of the event frame. (required)
     * @param string $name_filter The name query string used for filtering security entries. The default is no filter. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\ItemsSecurityEntry, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventFrameGetSecurityEntriesWithHttpInfo($web_id, $name_filter = null, $selected_fields = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling eventFrameGetSecurityEntries');
        }
        // parse inputs
        $resourcePath = "/eventframes/{webId}/securityentries";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($name_filter !== null) {
            $queryParams['nameFilter'] = $this->apiClient->getSerializer()->toQueryValue($name_filter);
        }
        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\ItemsSecurityEntry',
                '/eventframes/{webId}/securityentries'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\ItemsSecurityEntry', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsSecurityEntry', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation eventFrameGetSecurityEntryByName
     *
     * Retrieve the security entry associated with the event frame with the specified name.
     *
     * @param string $name The name of the security entry. For every backslash character (\\) in the security entry name, replace with asterisk (*). As an example, use domain*username instead of domain\\username. (required)
     * @param string $web_id The ID of the event frame. (required)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\SecurityEntry
     */
    public function eventFrameGetSecurityEntryByName($name, $web_id, $selected_fields = null)
    {
        list($response) = $this->eventFrameGetSecurityEntryByNameWithHttpInfo($name, $web_id, $selected_fields);
        return $response;
    }

    /**
     * Operation eventFrameGetSecurityEntryByNameWithHttpInfo
     *
     * Retrieve the security entry associated with the event frame with the specified name.
     *
     * @param string $name The name of the security entry. For every backslash character (\\) in the security entry name, replace with asterisk (*). As an example, use domain*username instead of domain\\username. (required)
     * @param string $web_id The ID of the event frame. (required)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\SecurityEntry, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventFrameGetSecurityEntryByNameWithHttpInfo($name, $web_id, $selected_fields = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling eventFrameGetSecurityEntryByName');
        }
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling eventFrameGetSecurityEntryByName');
        }
        // parse inputs
        $resourcePath = "/eventframes/{webId}/securityentries/{name}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                "{" . "name" . "}",
                $this->apiClient->getSerializer()->toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\SecurityEntry',
                '/eventframes/{webId}/securityentries/{name}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\SecurityEntry', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\SecurityEntry', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation eventFrameUpdate
     *
     * Update an event frame by replacing items in its definition.
     *
     * @param string $web_id The ID of the event frame to update. (required)
     * @param \PIWebAPI\Client\Model\EventFrame $event_frame A partial event frame containing the desired changes. (required)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return void
     */
    public function eventFrameUpdate($web_id, $event_frame)
    {
        list($response) = $this->eventFrameUpdateWithHttpInfo($web_id, $event_frame);
        return $response;
    }

    /**
     * Operation eventFrameUpdateWithHttpInfo
     *
     * Update an event frame by replacing items in its definition.
     *
     * @param string $web_id The ID of the event frame to update. (required)
     * @param \PIWebAPI\Client\Model\EventFrame $event_frame A partial event frame containing the desired changes. (required)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventFrameUpdateWithHttpInfo($web_id, $event_frame)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling eventFrameUpdate');
        }
        // verify the required parameter 'event_frame' is set
        if ($event_frame === null) {
            throw new \InvalidArgumentException('Missing the required parameter $event_frame when calling eventFrameUpdate');
        }
        // parse inputs
        $resourcePath = "/eventframes/{webId}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json', 'text/json']);

        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($event_frame)) {
            $_tempBody = $event_frame;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PATCH',
                $queryParams,
                $httpBody,
                $headerParams,
                null,
                '/eventframes/{webId}'
            );

            return [null, $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }

            throw $e;
        }
    }

    /**
     * Operation eventFrameUpdateAnnotation
     *
     * Update an annotation on an event frame by replacing items in its definition.
     *
     * @param string $id The Annotation identifier of the annotation to be updated. (required)
     * @param string $web_id The ID of the owner event frame of the annotation to update. (required)
     * @param \PIWebAPI\Client\Model\Annotation $annotation A partial annotation containing the desired changes. (required)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return void
     */
    public function eventFrameUpdateAnnotation($id, $web_id, $annotation)
    {
        list($response) = $this->eventFrameUpdateAnnotationWithHttpInfo($id, $web_id, $annotation);
        return $response;
    }

    /**
     * Operation eventFrameUpdateAnnotationWithHttpInfo
     *
     * Update an annotation on an event frame by replacing items in its definition.
     *
     * @param string $id The Annotation identifier of the annotation to be updated. (required)
     * @param string $web_id The ID of the owner event frame of the annotation to update. (required)
     * @param \PIWebAPI\Client\Model\Annotation $annotation A partial annotation containing the desired changes. (required)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventFrameUpdateAnnotationWithHttpInfo($id, $web_id, $annotation)
    {
        // verify the required parameter 'id' is set
        if ($id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling eventFrameUpdateAnnotation');
        }
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling eventFrameUpdateAnnotation');
        }
        // verify the required parameter 'annotation' is set
        if ($annotation === null) {
            throw new \InvalidArgumentException('Missing the required parameter $annotation when calling eventFrameUpdateAnnotation');
        }
        // parse inputs
        $resourcePath = "/eventframes/{webId}/annotations/{id}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json', 'text/json']);

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                "{" . "id" . "}",
                $this->apiClient->getSerializer()->toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($annotation)) {
            $_tempBody = $annotation;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PATCH',
                $queryParams,
                $httpBody,
                $headerParams,
                null,
                '/eventframes/{webId}/annotations/{id}'
            );

            return [null, $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }

            throw $e;
        }
    }

    /**
     * Operation eventFrameUpdateSecurityEntry
     *
     * Update a security entry owned by the event frame.
     *
     * @param string $name The name of the security entry. (required)
     * @param string $web_id The ID of the event frame where the security entry will be updated. (required)
     * @param \PIWebAPI\Client\Model\SecurityEntry $security_entry The new security entry definition. The full list of allow and deny rights must be supplied or they will be removed. (required)
     * @param bool $apply_to_children If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return void
     */
    public function eventFrameUpdateSecurityEntry($name, $web_id, $security_entry, $apply_to_children = null)
    {
        list($response) = $this->eventFrameUpdateSecurityEntryWithHttpInfo($name, $web_id, $security_entry, $apply_to_children);
        return $response;
    }

    /**
     * Operation eventFrameUpdateSecurityEntryWithHttpInfo
     *
     * Update a security entry owned by the event frame.
     *
     * @param string $name The name of the security entry. (required)
     * @param string $web_id The ID of the event frame where the security entry will be updated. (required)
     * @param \PIWebAPI\Client\Model\SecurityEntry $security_entry The new security entry definition. The full list of allow and deny rights must be supplied or they will be removed. (required)
     * @param bool $apply_to_children If false, the new access permissions are only applied to the associated object. If true, the access permissions of children with any parent-child reference types will change when the permissions on the primary parent change. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventFrameUpdateSecurityEntryWithHttpInfo($name, $web_id, $security_entry, $apply_to_children = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null) {
            throw new \InvalidArgumentException('Missing the required parameter $name when calling eventFrameUpdateSecurityEntry');
        }
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling eventFrameUpdateSecurityEntry');
        }
        // verify the required parameter 'security_entry' is set
        if ($security_entry === null) {
            throw new \InvalidArgumentException('Missing the required parameter $security_entry when calling eventFrameUpdateSecurityEntry');
        }
        // parse inputs
        $resourcePath = "/eventframes/{webId}/securityentries/{name}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json', 'text/json']);

        // query params
        if ($apply_to_children !== null) {
            $queryParams['applyToChildren'] = $this->apiClient->getSerializer()->toQueryValue($apply_to_children);
        }
        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                "{" . "name" . "}",
                $this->apiClient->getSerializer()->toPathValue($name),
                $resourcePath
            );
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($security_entry)) {
            $_tempBody = $security_entry;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                null,
                '/eventframes/{webId}/securityentries/{name}'
            );

            return [null, $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }

            throw $e;
        }
    }
}
