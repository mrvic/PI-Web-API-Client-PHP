<?php
/**
 * StreamApi
 * PHP version 5
 *
 * @category Class
 * @package  PIWebAPI\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * PI Web API 2017 Swagger Spec
 *
 * Swagger Spec file that describes PI Web API
 *
 * OpenAPI spec version: 1.9.0.235
 * Contact: techsupport@osisoft.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace PIWebAPI\Client\Api;

use \PIWebAPI\Client\ApiClient;
use \PIWebAPI\Client\ApiException;
use \PIWebAPI\Client\Configuration;
use \PIWebAPI\Client\ObjectSerializer;

/**
 * StreamApi Class Doc Comment
 *
 * @category Class
 * @package  PIWebAPI\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class StreamApi
{
    /**
     * API Client
     *
     * @var \PIWebAPI\Client\ApiClient instance of the ApiClient
     */
    protected $apiClient;

    /**
     * Constructor
     *
     * @param \PIWebAPI\Client\ApiClient|null $apiClient The api client to use
     */
    public function __construct(\PIWebAPI\Client\ApiClient $apiClient = null)
    {
        if ($apiClient === null) {
            $apiClient = new ApiClient();
            $apiClient->getConfig()->setHost('https://proghackuc2017.osisoft.com/piwebapi');
        }

        $this->apiClient = $apiClient;
    }

    /**
     * Get API client
     *
     * @return \PIWebAPI\Client\ApiClient get the API client
     */
    public function getApiClient()
    {
        return $this->apiClient;
    }

    /**
     * Set the API client
     *
     * @param \PIWebAPI\Client\ApiClient $apiClient set the API client
     *
     * @return StreamApi
     */
    public function setApiClient(\PIWebAPI\Client\ApiClient $apiClient)
    {
        $this->apiClient = $apiClient;
        return $this;
    }

    /**
     * Operation streamGetChannel
     *
     * Opens a channel that will send messages about any value changes for the specified stream.
     *
     * @param string $web_id The ID of the stream. (required)
     * @param bool $include_initial_values Specified if the channel should send a message with the current value of the stream after the connection is opened. The default is &#39;false&#39;. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return void
     */
    public function streamGetChannel($web_id, $include_initial_values = null)
    {
        list($response) = $this->streamGetChannelWithHttpInfo($web_id, $include_initial_values);
        return $response;
    }

    /**
     * Operation streamGetChannelWithHttpInfo
     *
     * Opens a channel that will send messages about any value changes for the specified stream.
     *
     * @param string $web_id The ID of the stream. (required)
     * @param bool $include_initial_values Specified if the channel should send a message with the current value of the stream after the connection is opened. The default is &#39;false&#39;. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamGetChannelWithHttpInfo($web_id, $include_initial_values = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling streamGetChannel');
        }
        // parse inputs
        $resourcePath = "/streams/{webId}/channel";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($include_initial_values !== null) {
            $queryParams['includeInitialValues'] = $this->apiClient->getSerializer()->toQueryValue($include_initial_values);
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                null,
                '/streams/{webId}/channel'
            );

            return [null, $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 101:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsStreamValues', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation streamGetEnd
     *
     * Returns the end-of-stream value of the stream.
     *
     * @param string $web_id The ID of the stream. (required)
     * @param string $desired_units The name or abbreviation of the desired units of measure for the returned value, as found in the UOM database associated with the attribute. If not specified for an attribute, the attribute&#39;s default unit of measure is used. If the underlying stream is a point, this value may not be specified, as points are not associated with a unit of measure. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\TimedValue
     */
    public function streamGetEnd($web_id, $desired_units = null, $selected_fields = null)
    {
        list($response) = $this->streamGetEndWithHttpInfo($web_id, $desired_units, $selected_fields);
        return $response;
    }

    /**
     * Operation streamGetEndWithHttpInfo
     *
     * Returns the end-of-stream value of the stream.
     *
     * @param string $web_id The ID of the stream. (required)
     * @param string $desired_units The name or abbreviation of the desired units of measure for the returned value, as found in the UOM database associated with the attribute. If not specified for an attribute, the attribute&#39;s default unit of measure is used. If the underlying stream is a point, this value may not be specified, as points are not associated with a unit of measure. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\TimedValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamGetEndWithHttpInfo($web_id, $desired_units = null, $selected_fields = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling streamGetEnd');
        }
        // parse inputs
        $resourcePath = "/streams/{webId}/end";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($desired_units !== null) {
            $queryParams['desiredUnits'] = $this->apiClient->getSerializer()->toQueryValue($desired_units);
        }
        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\TimedValue',
                '/streams/{webId}/end'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\TimedValue', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\TimedValue', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation streamGetInterpolated
     *
     * Retrieves interpolated values over the specified time range at the specified sampling interval.
     *
     * @param string $web_id The ID of the stream. (required)
     * @param string $desired_units The name or abbreviation of the desired units of measure for the returned value, as found in the UOM database associated with the attribute. If not specified for an attribute, the attribute&#39;s default unit of measure is used. If the underlying stream is a point, this value may not be specified, as points are not associated with a unit of measure. (optional)
     * @param string $end_time An optional end time. The default is &#39;*&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s end time, or &#39;*&#39; if that is not set. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order. (optional)
     * @param string $filter_expression An optional string containing a filter expression. Expression variables are relative to the data point. Use &#39;.&#39; to reference the containing attribute. If the attribute does not support filtering, the filter will be ignored. The default is no filtering. (optional)
     * @param bool $include_filtered_values Specify &#39;true&#39; to indicate that values which fail the filter criteria are present in the returned data at the times where they occurred with a value set to a &#39;Filtered&#39; enumeration value with bad status. Repeated consecutive failures are omitted. (optional)
     * @param string $interval The sampling interval, in AFTimeSpan format. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string $start_time An optional start time. The default is &#39;*-1d&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s start time, or &#39;*-1d&#39; if that is not set. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\TimedValues
     */
    public function streamGetInterpolated($web_id, $desired_units = null, $end_time = null, $filter_expression = null, $include_filtered_values = null, $interval = null, $selected_fields = null, $start_time = null, $time_zone = null)
    {
        list($response) = $this->streamGetInterpolatedWithHttpInfo($web_id, $desired_units, $end_time, $filter_expression, $include_filtered_values, $interval, $selected_fields, $start_time, $time_zone);
        return $response;
    }

    /**
     * Operation streamGetInterpolatedWithHttpInfo
     *
     * Retrieves interpolated values over the specified time range at the specified sampling interval.
     *
     * @param string $web_id The ID of the stream. (required)
     * @param string $desired_units The name or abbreviation of the desired units of measure for the returned value, as found in the UOM database associated with the attribute. If not specified for an attribute, the attribute&#39;s default unit of measure is used. If the underlying stream is a point, this value may not be specified, as points are not associated with a unit of measure. (optional)
     * @param string $end_time An optional end time. The default is &#39;*&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s end time, or &#39;*&#39; if that is not set. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order. (optional)
     * @param string $filter_expression An optional string containing a filter expression. Expression variables are relative to the data point. Use &#39;.&#39; to reference the containing attribute. If the attribute does not support filtering, the filter will be ignored. The default is no filtering. (optional)
     * @param bool $include_filtered_values Specify &#39;true&#39; to indicate that values which fail the filter criteria are present in the returned data at the times where they occurred with a value set to a &#39;Filtered&#39; enumeration value with bad status. Repeated consecutive failures are omitted. (optional)
     * @param string $interval The sampling interval, in AFTimeSpan format. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string $start_time An optional start time. The default is &#39;*-1d&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s start time, or &#39;*-1d&#39; if that is not set. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\TimedValues, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamGetInterpolatedWithHttpInfo($web_id, $desired_units = null, $end_time = null, $filter_expression = null, $include_filtered_values = null, $interval = null, $selected_fields = null, $start_time = null, $time_zone = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling streamGetInterpolated');
        }
        // parse inputs
        $resourcePath = "/streams/{webId}/interpolated";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($desired_units !== null) {
            $queryParams['desiredUnits'] = $this->apiClient->getSerializer()->toQueryValue($desired_units);
        }
        // query params
        if ($end_time !== null) {
            $queryParams['endTime'] = $this->apiClient->getSerializer()->toQueryValue($end_time);
        }
        // query params
        if ($filter_expression !== null) {
            $queryParams['filterExpression'] = $this->apiClient->getSerializer()->toQueryValue($filter_expression);
        }
        // query params
        if ($include_filtered_values !== null) {
            $queryParams['includeFilteredValues'] = $this->apiClient->getSerializer()->toQueryValue($include_filtered_values);
        }
        // query params
        if ($interval !== null) {
            $queryParams['interval'] = $this->apiClient->getSerializer()->toQueryValue($interval);
        }
        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // query params
        if ($start_time !== null) {
            $queryParams['startTime'] = $this->apiClient->getSerializer()->toQueryValue($start_time);
        }
        // query params
        if ($time_zone !== null) {
            $queryParams['timeZone'] = $this->apiClient->getSerializer()->toQueryValue($time_zone);
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\TimedValues',
                '/streams/{webId}/interpolated'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\TimedValues', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\TimedValues', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation streamGetInterpolatedAtTimes
     *
     * Retrieves interpolated values over the specified time range at the specified sampling interval.
     *
     * @param string $web_id The ID of the stream. (required)
     * @param string $desired_units The name or abbreviation of the desired units of measure for the returned value, as found in the UOM database associated with the attribute. If not specified for an attribute, the attribute&#39;s default unit of measure is used. If the underlying stream is a point, this value may not be specified, as points are not associated with a unit of measure. (optional)
     * @param string $filter_expression An optional string containing a filter expression. Expression variables are relative to the data point. Use &#39;.&#39; to reference the containing attribute. If the attribute does not support filtering, the filter will be ignored. The default is no filtering. (optional)
     * @param bool $include_filtered_values Specify &#39;true&#39; to indicate that values which fail the filter criteria are present in the returned data at the times where they occurred with a value set to a &#39;Filtered&#39; enumeration value with bad status. Repeated consecutive failures are omitted. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string $sort_order The order that the returned collection is sorted. The default is &#39;Ascending&#39;. (optional)
     * @param string[] $time The timestamp at which to retrieve an interpolated value. Multiple timestamps may be specified with multiple instances of the parameter. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\TimedValues
     */
    public function streamGetInterpolatedAtTimes($web_id, $desired_units = null, $filter_expression = null, $include_filtered_values = null, $selected_fields = null, $sort_order = null, $time = null, $time_zone = null)
    {
        list($response) = $this->streamGetInterpolatedAtTimesWithHttpInfo($web_id, $desired_units, $filter_expression, $include_filtered_values, $selected_fields, $sort_order, $time, $time_zone);
        return $response;
    }

    /**
     * Operation streamGetInterpolatedAtTimesWithHttpInfo
     *
     * Retrieves interpolated values over the specified time range at the specified sampling interval.
     *
     * @param string $web_id The ID of the stream. (required)
     * @param string $desired_units The name or abbreviation of the desired units of measure for the returned value, as found in the UOM database associated with the attribute. If not specified for an attribute, the attribute&#39;s default unit of measure is used. If the underlying stream is a point, this value may not be specified, as points are not associated with a unit of measure. (optional)
     * @param string $filter_expression An optional string containing a filter expression. Expression variables are relative to the data point. Use &#39;.&#39; to reference the containing attribute. If the attribute does not support filtering, the filter will be ignored. The default is no filtering. (optional)
     * @param bool $include_filtered_values Specify &#39;true&#39; to indicate that values which fail the filter criteria are present in the returned data at the times where they occurred with a value set to a &#39;Filtered&#39; enumeration value with bad status. Repeated consecutive failures are omitted. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string $sort_order The order that the returned collection is sorted. The default is &#39;Ascending&#39;. (optional)
     * @param string[] $time The timestamp at which to retrieve an interpolated value. Multiple timestamps may be specified with multiple instances of the parameter. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\TimedValues, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamGetInterpolatedAtTimesWithHttpInfo($web_id, $desired_units = null, $filter_expression = null, $include_filtered_values = null, $selected_fields = null, $sort_order = null, $time = null, $time_zone = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling streamGetInterpolatedAtTimes');
        }
        // parse inputs
        $resourcePath = "/streams/{webId}/interpolatedattimes";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($desired_units !== null) {
            $queryParams['desiredUnits'] = $this->apiClient->getSerializer()->toQueryValue($desired_units);
        }
        // query params
        if ($filter_expression !== null) {
            $queryParams['filterExpression'] = $this->apiClient->getSerializer()->toQueryValue($filter_expression);
        }
        // query params
        if ($include_filtered_values !== null) {
            $queryParams['includeFilteredValues'] = $this->apiClient->getSerializer()->toQueryValue($include_filtered_values);
        }
        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // query params
        if ($sort_order !== null) {
            $queryParams['sortOrder'] = $this->apiClient->getSerializer()->toQueryValue($sort_order);
        }
        // query params
        if (is_array($time)) {
            $time = $this->apiClient->getSerializer()->serializeCollection($time, 'multi', true);
        }
        if ($time !== null) {
            $queryParams['time'] = $this->apiClient->getSerializer()->toQueryValue($time);
        }
        // query params
        if ($time_zone !== null) {
            $queryParams['timeZone'] = $this->apiClient->getSerializer()->toQueryValue($time_zone);
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\TimedValues',
                '/streams/{webId}/interpolatedattimes'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\TimedValues', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\TimedValues', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation streamGetPlot
     *
     * Retrieves values over the specified time range suitable for plotting over the number of intervals (typically represents pixels).
     *
     * @param string $web_id The ID of the stream. (required)
     * @param string $desired_units The name or abbreviation of the desired units of measure for the returned value, as found in the UOM database associated with the attribute. If not specified for an attribute, the attribute&#39;s default unit of measure is used. If the underlying stream is a point, this value may not be specified, as points are not associated with a unit of measure. (optional)
     * @param string $end_time An optional end time. The default is &#39;*&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s end time, or &#39;*&#39; if that is not set. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order. (optional)
     * @param int $intervals The number of intervals to plot over. Typically, this would be the number of horizontal pixels in the trend. The default is &#39;24&#39;. For each interval, the data available is examined and significant values are returned. Each interval can produce up to 5 values if they are unique, the first value in the interval, the last value, the highest value, the lowest value and at most one exceptional point (bad status or digital state). (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string $start_time An optional start time. The default is &#39;*-1d&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s start time, or &#39;*-1d&#39; if that is not set. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\TimedValues
     */
    public function streamGetPlot($web_id, $desired_units = null, $end_time = null, $intervals = null, $selected_fields = null, $start_time = null, $time_zone = null)
    {
        list($response) = $this->streamGetPlotWithHttpInfo($web_id, $desired_units, $end_time, $intervals, $selected_fields, $start_time, $time_zone);
        return $response;
    }

    /**
     * Operation streamGetPlotWithHttpInfo
     *
     * Retrieves values over the specified time range suitable for plotting over the number of intervals (typically represents pixels).
     *
     * @param string $web_id The ID of the stream. (required)
     * @param string $desired_units The name or abbreviation of the desired units of measure for the returned value, as found in the UOM database associated with the attribute. If not specified for an attribute, the attribute&#39;s default unit of measure is used. If the underlying stream is a point, this value may not be specified, as points are not associated with a unit of measure. (optional)
     * @param string $end_time An optional end time. The default is &#39;*&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s end time, or &#39;*&#39; if that is not set. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order. (optional)
     * @param int $intervals The number of intervals to plot over. Typically, this would be the number of horizontal pixels in the trend. The default is &#39;24&#39;. For each interval, the data available is examined and significant values are returned. Each interval can produce up to 5 values if they are unique, the first value in the interval, the last value, the highest value, the lowest value and at most one exceptional point (bad status or digital state). (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string $start_time An optional start time. The default is &#39;*-1d&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s start time, or &#39;*-1d&#39; if that is not set. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\TimedValues, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamGetPlotWithHttpInfo($web_id, $desired_units = null, $end_time = null, $intervals = null, $selected_fields = null, $start_time = null, $time_zone = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling streamGetPlot');
        }
        // parse inputs
        $resourcePath = "/streams/{webId}/plot";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($desired_units !== null) {
            $queryParams['desiredUnits'] = $this->apiClient->getSerializer()->toQueryValue($desired_units);
        }
        // query params
        if ($end_time !== null) {
            $queryParams['endTime'] = $this->apiClient->getSerializer()->toQueryValue($end_time);
        }
        // query params
        if ($intervals !== null) {
            $queryParams['intervals'] = $this->apiClient->getSerializer()->toQueryValue($intervals);
        }
        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // query params
        if ($start_time !== null) {
            $queryParams['startTime'] = $this->apiClient->getSerializer()->toQueryValue($start_time);
        }
        // query params
        if ($time_zone !== null) {
            $queryParams['timeZone'] = $this->apiClient->getSerializer()->toQueryValue($time_zone);
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\TimedValues',
                '/streams/{webId}/plot'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\TimedValues', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\TimedValues', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation streamGetRecorded
     *
     * Returns a list of compressed values for the requested time range from the source provider.
     *
     * @param string $web_id The ID of the stream. (required)
     * @param string $boundary_type An optional value that determines how the times and values of the returned end points are determined. The default is &#39;Inside&#39;. (optional)
     * @param string $desired_units The name or abbreviation of the desired units of measure for the returned value, as found in the UOM database associated with the attribute. If not specified for an attribute, the attribute&#39;s default unit of measure is used. If the underlying stream is a point, this value may not be specified, as points are not associated with a unit of measure. (optional)
     * @param string $end_time An optional end time. The default is &#39;*&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s end time, or &#39;*&#39; if that is not set. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order. (optional)
     * @param string $filter_expression An optional string containing a filter expression. Expression variables are relative to the data point. Use &#39;.&#39; to reference the containing attribute. The default is no filtering. (optional)
     * @param bool $include_filtered_values Specify &#39;true&#39; to indicate that values which fail the filter criteria are present in the returned data at the times where they occurred with a value set to a &#39;Filtered&#39; enumeration value with bad status. Repeated consecutive failures are omitted. (optional)
     * @param int $max_count The maximum number of values to be returned. The default is 1000. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string $start_time An optional start time. The default is &#39;*-1d&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s start time, or &#39;*-1d&#39; if that is not set. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\TimedValues
     */
    public function streamGetRecorded($web_id, $boundary_type = null, $desired_units = null, $end_time = null, $filter_expression = null, $include_filtered_values = null, $max_count = null, $selected_fields = null, $start_time = null, $time_zone = null)
    {
        list($response) = $this->streamGetRecordedWithHttpInfo($web_id, $boundary_type, $desired_units, $end_time, $filter_expression, $include_filtered_values, $max_count, $selected_fields, $start_time, $time_zone);
        return $response;
    }

    /**
     * Operation streamGetRecordedWithHttpInfo
     *
     * Returns a list of compressed values for the requested time range from the source provider.
     *
     * @param string $web_id The ID of the stream. (required)
     * @param string $boundary_type An optional value that determines how the times and values of the returned end points are determined. The default is &#39;Inside&#39;. (optional)
     * @param string $desired_units The name or abbreviation of the desired units of measure for the returned value, as found in the UOM database associated with the attribute. If not specified for an attribute, the attribute&#39;s default unit of measure is used. If the underlying stream is a point, this value may not be specified, as points are not associated with a unit of measure. (optional)
     * @param string $end_time An optional end time. The default is &#39;*&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s end time, or &#39;*&#39; if that is not set. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order. (optional)
     * @param string $filter_expression An optional string containing a filter expression. Expression variables are relative to the data point. Use &#39;.&#39; to reference the containing attribute. The default is no filtering. (optional)
     * @param bool $include_filtered_values Specify &#39;true&#39; to indicate that values which fail the filter criteria are present in the returned data at the times where they occurred with a value set to a &#39;Filtered&#39; enumeration value with bad status. Repeated consecutive failures are omitted. (optional)
     * @param int $max_count The maximum number of values to be returned. The default is 1000. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string $start_time An optional start time. The default is &#39;*-1d&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s start time, or &#39;*-1d&#39; if that is not set. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\TimedValues, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamGetRecordedWithHttpInfo($web_id, $boundary_type = null, $desired_units = null, $end_time = null, $filter_expression = null, $include_filtered_values = null, $max_count = null, $selected_fields = null, $start_time = null, $time_zone = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling streamGetRecorded');
        }
        // parse inputs
        $resourcePath = "/streams/{webId}/recorded";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($boundary_type !== null) {
            $queryParams['boundaryType'] = $this->apiClient->getSerializer()->toQueryValue($boundary_type);
        }
        // query params
        if ($desired_units !== null) {
            $queryParams['desiredUnits'] = $this->apiClient->getSerializer()->toQueryValue($desired_units);
        }
        // query params
        if ($end_time !== null) {
            $queryParams['endTime'] = $this->apiClient->getSerializer()->toQueryValue($end_time);
        }
        // query params
        if ($filter_expression !== null) {
            $queryParams['filterExpression'] = $this->apiClient->getSerializer()->toQueryValue($filter_expression);
        }
        // query params
        if ($include_filtered_values !== null) {
            $queryParams['includeFilteredValues'] = $this->apiClient->getSerializer()->toQueryValue($include_filtered_values);
        }
        // query params
        if ($max_count !== null) {
            $queryParams['maxCount'] = $this->apiClient->getSerializer()->toQueryValue($max_count);
        }
        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // query params
        if ($start_time !== null) {
            $queryParams['startTime'] = $this->apiClient->getSerializer()->toQueryValue($start_time);
        }
        // query params
        if ($time_zone !== null) {
            $queryParams['timeZone'] = $this->apiClient->getSerializer()->toQueryValue($time_zone);
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\TimedValues',
                '/streams/{webId}/recorded'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\TimedValues', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\TimedValues', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation streamGetRecordedAtTime
     *
     * Returns a single recorded value based on the passed time and retrieval mode from the stream.
     *
     * @param string $web_id The ID of the stream. (required)
     * @param string $time The timestamp at which the value is desired. (required)
     * @param string $desired_units The name or abbreviation of the desired units of measure for the returned value, as found in the UOM database associated with the attribute. If not specified for an attribute, the attribute&#39;s default unit of measure is used. If the underlying stream is a point, this value may not be specified, as points are not associated with a unit of measure. (optional)
     * @param string $retrieval_mode An optional value that determines the value to return when a value doesn&#39;t exist at the exact time specified. The default is &#39;Auto&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\TimedValue
     */
    public function streamGetRecordedAtTime($web_id, $time, $desired_units = null, $retrieval_mode = null, $selected_fields = null, $time_zone = null)
    {
        list($response) = $this->streamGetRecordedAtTimeWithHttpInfo($web_id, $time, $desired_units, $retrieval_mode, $selected_fields, $time_zone);
        return $response;
    }

    /**
     * Operation streamGetRecordedAtTimeWithHttpInfo
     *
     * Returns a single recorded value based on the passed time and retrieval mode from the stream.
     *
     * @param string $web_id The ID of the stream. (required)
     * @param string $time The timestamp at which the value is desired. (required)
     * @param string $desired_units The name or abbreviation of the desired units of measure for the returned value, as found in the UOM database associated with the attribute. If not specified for an attribute, the attribute&#39;s default unit of measure is used. If the underlying stream is a point, this value may not be specified, as points are not associated with a unit of measure. (optional)
     * @param string $retrieval_mode An optional value that determines the value to return when a value doesn&#39;t exist at the exact time specified. The default is &#39;Auto&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\TimedValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamGetRecordedAtTimeWithHttpInfo($web_id, $time, $desired_units = null, $retrieval_mode = null, $selected_fields = null, $time_zone = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling streamGetRecordedAtTime');
        }
        // verify the required parameter 'time' is set
        if ($time === null) {
            throw new \InvalidArgumentException('Missing the required parameter $time when calling streamGetRecordedAtTime');
        }
        // parse inputs
        $resourcePath = "/streams/{webId}/recordedattime";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($time !== null) {
            $queryParams['time'] = $this->apiClient->getSerializer()->toQueryValue($time);
        }
        // query params
        if ($desired_units !== null) {
            $queryParams['desiredUnits'] = $this->apiClient->getSerializer()->toQueryValue($desired_units);
        }
        // query params
        if ($retrieval_mode !== null) {
            $queryParams['retrievalMode'] = $this->apiClient->getSerializer()->toQueryValue($retrieval_mode);
        }
        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // query params
        if ($time_zone !== null) {
            $queryParams['timeZone'] = $this->apiClient->getSerializer()->toQueryValue($time_zone);
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\TimedValue',
                '/streams/{webId}/recordedattime'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\TimedValue', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\TimedValue', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation streamGetRecordedAtTimes
     *
     * Retrieves recorded values at the specified times.
     *
     * @param string $web_id The ID of the stream. (required)
     * @param string $desired_units The name or abbreviation of the desired units of measure for the returned value, as found in the UOM database associated with the attribute. If not specified for an attribute, the attribute&#39;s default unit of measure is used. If the underlying stream is a point, this value may not be specified, as points are not associated with a unit of measure. (optional)
     * @param string $retrieval_mode An optional value that determines the value to return when a value doesn&#39;t exist at the exact time specified. The default is &#39;Auto&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string $sort_order The order that the returned collection is sorted. The default is &#39;Ascending&#39;. (optional)
     * @param string[] $time The timestamp at which to retrieve a recorded value. Multiple timestamps may be specified with multiple instances of the parameter. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\TimedValues
     */
    public function streamGetRecordedAtTimes($web_id, $desired_units = null, $retrieval_mode = null, $selected_fields = null, $sort_order = null, $time = null, $time_zone = null)
    {
        list($response) = $this->streamGetRecordedAtTimesWithHttpInfo($web_id, $desired_units, $retrieval_mode, $selected_fields, $sort_order, $time, $time_zone);
        return $response;
    }

    /**
     * Operation streamGetRecordedAtTimesWithHttpInfo
     *
     * Retrieves recorded values at the specified times.
     *
     * @param string $web_id The ID of the stream. (required)
     * @param string $desired_units The name or abbreviation of the desired units of measure for the returned value, as found in the UOM database associated with the attribute. If not specified for an attribute, the attribute&#39;s default unit of measure is used. If the underlying stream is a point, this value may not be specified, as points are not associated with a unit of measure. (optional)
     * @param string $retrieval_mode An optional value that determines the value to return when a value doesn&#39;t exist at the exact time specified. The default is &#39;Auto&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string $sort_order The order that the returned collection is sorted. The default is &#39;Ascending&#39;. (optional)
     * @param string[] $time The timestamp at which to retrieve a recorded value. Multiple timestamps may be specified with multiple instances of the parameter. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\TimedValues, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamGetRecordedAtTimesWithHttpInfo($web_id, $desired_units = null, $retrieval_mode = null, $selected_fields = null, $sort_order = null, $time = null, $time_zone = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling streamGetRecordedAtTimes');
        }
        // parse inputs
        $resourcePath = "/streams/{webId}/recordedattimes";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($desired_units !== null) {
            $queryParams['desiredUnits'] = $this->apiClient->getSerializer()->toQueryValue($desired_units);
        }
        // query params
        if ($retrieval_mode !== null) {
            $queryParams['retrievalMode'] = $this->apiClient->getSerializer()->toQueryValue($retrieval_mode);
        }
        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // query params
        if ($sort_order !== null) {
            $queryParams['sortOrder'] = $this->apiClient->getSerializer()->toQueryValue($sort_order);
        }
        // query params
        if (is_array($time)) {
            $time = $this->apiClient->getSerializer()->serializeCollection($time, 'multi', true);
        }
        if ($time !== null) {
            $queryParams['time'] = $this->apiClient->getSerializer()->toQueryValue($time);
        }
        // query params
        if ($time_zone !== null) {
            $queryParams['timeZone'] = $this->apiClient->getSerializer()->toQueryValue($time_zone);
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\TimedValues',
                '/streams/{webId}/recordedattimes'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\TimedValues', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\TimedValues', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation streamGetSummary
     *
     * Returns a summary over the specified time range for the stream.
     *
     * @param string $web_id The ID of the stream. (required)
     * @param string $calculation_basis Specifies the method of evaluating the data over the time range. The default is &#39;TimeWeighted&#39;. (optional)
     * @param string $end_time An optional end time. The default is &#39;*&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s end time, or &#39;*&#39; if that is not set. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order. (optional)
     * @param string $filter_expression A string containing a filter expression. Expression variables are relative to the attribute. Use &#39;.&#39; to reference the containing attribute. (optional)
     * @param string $sample_interval When the sampleType is Interval, sampleInterval specifies how often the filter expression is evaluated when computing the summary for an interval. (optional)
     * @param string $sample_type Defines the evaluation of an expression over a time range. The default is &#39;ExpressionRecordedValues&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string $start_time An optional start time. The default is &#39;*-1d&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s start time, or &#39;*-1d&#39; if that is not set. (optional)
     * @param string $summary_duration The duration of each summary interval. If specified in hours, minutes, seconds, or milliseconds, the summary durations will be evenly spaced UTC time intervals. Longer interval types are interpreted using wall clock rules and are time zone dependent. (optional)
     * @param string[] $summary_type Specifies the kinds of summaries to produce over the range. The default is &#39;Total&#39;. Multiple summary types may be specified by using multiple instances of summaryType. (optional)
     * @param string $time_type Specifies how to calculate the timestamp for each interval. The default is &#39;Auto&#39;. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\ItemsSummaryValue
     */
    public function streamGetSummary($web_id, $calculation_basis = null, $end_time = null, $filter_expression = null, $sample_interval = null, $sample_type = null, $selected_fields = null, $start_time = null, $summary_duration = null, $summary_type = null, $time_type = null, $time_zone = null)
    {
        list($response) = $this->streamGetSummaryWithHttpInfo($web_id, $calculation_basis, $end_time, $filter_expression, $sample_interval, $sample_type, $selected_fields, $start_time, $summary_duration, $summary_type, $time_type, $time_zone);
        return $response;
    }

    /**
     * Operation streamGetSummaryWithHttpInfo
     *
     * Returns a summary over the specified time range for the stream.
     *
     * @param string $web_id The ID of the stream. (required)
     * @param string $calculation_basis Specifies the method of evaluating the data over the time range. The default is &#39;TimeWeighted&#39;. (optional)
     * @param string $end_time An optional end time. The default is &#39;*&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s end time, or &#39;*&#39; if that is not set. Note that if endTime is earlier than startTime, the resulting values will be in time-descending order. (optional)
     * @param string $filter_expression A string containing a filter expression. Expression variables are relative to the attribute. Use &#39;.&#39; to reference the containing attribute. (optional)
     * @param string $sample_interval When the sampleType is Interval, sampleInterval specifies how often the filter expression is evaluated when computing the summary for an interval. (optional)
     * @param string $sample_type Defines the evaluation of an expression over a time range. The default is &#39;ExpressionRecordedValues&#39;. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string $start_time An optional start time. The default is &#39;*-1d&#39; for element attributes and points. For event frame attributes, the default is the event frame&#39;s start time, or &#39;*-1d&#39; if that is not set. (optional)
     * @param string $summary_duration The duration of each summary interval. If specified in hours, minutes, seconds, or milliseconds, the summary durations will be evenly spaced UTC time intervals. Longer interval types are interpreted using wall clock rules and are time zone dependent. (optional)
     * @param string[] $summary_type Specifies the kinds of summaries to produce over the range. The default is &#39;Total&#39;. Multiple summary types may be specified by using multiple instances of summaryType. (optional)
     * @param string $time_type Specifies how to calculate the timestamp for each interval. The default is &#39;Auto&#39;. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\ItemsSummaryValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamGetSummaryWithHttpInfo($web_id, $calculation_basis = null, $end_time = null, $filter_expression = null, $sample_interval = null, $sample_type = null, $selected_fields = null, $start_time = null, $summary_duration = null, $summary_type = null, $time_type = null, $time_zone = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling streamGetSummary');
        }
        // parse inputs
        $resourcePath = "/streams/{webId}/summary";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($calculation_basis !== null) {
            $queryParams['calculationBasis'] = $this->apiClient->getSerializer()->toQueryValue($calculation_basis);
        }
        // query params
        if ($end_time !== null) {
            $queryParams['endTime'] = $this->apiClient->getSerializer()->toQueryValue($end_time);
        }
        // query params
        if ($filter_expression !== null) {
            $queryParams['filterExpression'] = $this->apiClient->getSerializer()->toQueryValue($filter_expression);
        }
        // query params
        if ($sample_interval !== null) {
            $queryParams['sampleInterval'] = $this->apiClient->getSerializer()->toQueryValue($sample_interval);
        }
        // query params
        if ($sample_type !== null) {
            $queryParams['sampleType'] = $this->apiClient->getSerializer()->toQueryValue($sample_type);
        }
        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // query params
        if ($start_time !== null) {
            $queryParams['startTime'] = $this->apiClient->getSerializer()->toQueryValue($start_time);
        }
        // query params
        if ($summary_duration !== null) {
            $queryParams['summaryDuration'] = $this->apiClient->getSerializer()->toQueryValue($summary_duration);
        }
        // query params
        if (is_array($summary_type)) {
            $summary_type = $this->apiClient->getSerializer()->serializeCollection($summary_type, 'multi', true);
        }
        if ($summary_type !== null) {
            $queryParams['summaryType'] = $this->apiClient->getSerializer()->toQueryValue($summary_type);
        }
        // query params
        if ($time_type !== null) {
            $queryParams['timeType'] = $this->apiClient->getSerializer()->toQueryValue($time_type);
        }
        // query params
        if ($time_zone !== null) {
            $queryParams['timeZone'] = $this->apiClient->getSerializer()->toQueryValue($time_zone);
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\ItemsSummaryValue',
                '/streams/{webId}/summary'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\ItemsSummaryValue', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsSummaryValue', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation streamGetValue
     *
     * Returns the value of the stream at the specified time. By default, this is usually the current value.
     *
     * @param string $web_id The ID of the stream. (required)
     * @param string $desired_units The name or abbreviation of the desired units of measure for the returned value, as found in the UOM database associated with the attribute. If not specified for an attribute, the attribute&#39;s default unit of measure is used. If the underlying stream is a point, this value may not be specified, as points are not associated with a unit of measure. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string $time An optional time. The default time context is determined from the owning object - for example, the time range of the event frame or transfer which holds this attribute. Otherwise, the implementation of the Data Reference determines the meaning of no context. For Points or simply configured PI Point Data References, this means the snapshot value of the PI Point on the Data Server. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\TimedValue
     */
    public function streamGetValue($web_id, $desired_units = null, $selected_fields = null, $time = null, $time_zone = null)
    {
        list($response) = $this->streamGetValueWithHttpInfo($web_id, $desired_units, $selected_fields, $time, $time_zone);
        return $response;
    }

    /**
     * Operation streamGetValueWithHttpInfo
     *
     * Returns the value of the stream at the specified time. By default, this is usually the current value.
     *
     * @param string $web_id The ID of the stream. (required)
     * @param string $desired_units The name or abbreviation of the desired units of measure for the returned value, as found in the UOM database associated with the attribute. If not specified for an attribute, the attribute&#39;s default unit of measure is used. If the underlying stream is a point, this value may not be specified, as points are not associated with a unit of measure. (optional)
     * @param string $selected_fields List of fields to be returned in the response, separated by semicolons (;). If this parameter is not specified, all available fields will be returned. (optional)
     * @param string $time An optional time. The default time context is determined from the owning object - for example, the time range of the event frame or transfer which holds this attribute. Otherwise, the implementation of the Data Reference determines the meaning of no context. For Points or simply configured PI Point Data References, this means the snapshot value of the PI Point on the Data Server. (optional)
     * @param string $time_zone The time zone in which the time string will be interpreted. This parameter will be ignored if a time zone is specified in the time string. If no time zone is specified in either places, the PI Web API server time zone will be used. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\TimedValue, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamGetValueWithHttpInfo($web_id, $desired_units = null, $selected_fields = null, $time = null, $time_zone = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling streamGetValue');
        }
        // parse inputs
        $resourcePath = "/streams/{webId}/value";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($desired_units !== null) {
            $queryParams['desiredUnits'] = $this->apiClient->getSerializer()->toQueryValue($desired_units);
        }
        // query params
        if ($selected_fields !== null) {
            $queryParams['selectedFields'] = $this->apiClient->getSerializer()->toQueryValue($selected_fields);
        }
        // query params
        if ($time !== null) {
            $queryParams['time'] = $this->apiClient->getSerializer()->toQueryValue($time);
        }
        // query params
        if ($time_zone !== null) {
            $queryParams['timeZone'] = $this->apiClient->getSerializer()->toQueryValue($time_zone);
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\TimedValue',
                '/streams/{webId}/value'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\TimedValue', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\TimedValue', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation streamUpdateValue
     *
     * Updates a value for the specified stream.
     *
     * @param string $web_id The ID of the stream. (required)
     * @param \PIWebAPI\Client\Model\TimedValue $value The value to add or update. (required)
     * @param string $buffer_option The desired AFBufferOption. The default is &#39;BufferIfPossible&#39;. (optional)
     * @param string $update_option The desired AFUpdateOption. The default is &#39;Replace&#39;. This parameter is ignored if the attribute is a configuration item. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return void
     */
    public function streamUpdateValue($web_id, $value, $buffer_option = null, $update_option = null)
    {
        list($response) = $this->streamUpdateValueWithHttpInfo($web_id, $value, $buffer_option, $update_option);
        return $response;
    }

    /**
     * Operation streamUpdateValueWithHttpInfo
     *
     * Updates a value for the specified stream.
     *
     * @param string $web_id The ID of the stream. (required)
     * @param \PIWebAPI\Client\Model\TimedValue $value The value to add or update. (required)
     * @param string $buffer_option The desired AFBufferOption. The default is &#39;BufferIfPossible&#39;. (optional)
     * @param string $update_option The desired AFUpdateOption. The default is &#39;Replace&#39;. This parameter is ignored if the attribute is a configuration item. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamUpdateValueWithHttpInfo($web_id, $value, $buffer_option = null, $update_option = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling streamUpdateValue');
        }
        // verify the required parameter 'value' is set
        if ($value === null) {
            throw new \InvalidArgumentException('Missing the required parameter $value when calling streamUpdateValue');
        }
        // parse inputs
        $resourcePath = "/streams/{webId}/value";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json', 'text/json']);

        // query params
        if ($buffer_option !== null) {
            $queryParams['bufferOption'] = $this->apiClient->getSerializer()->toQueryValue($buffer_option);
        }
        // query params
        if ($update_option !== null) {
            $queryParams['updateOption'] = $this->apiClient->getSerializer()->toQueryValue($update_option);
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($value)) {
            $_tempBody = $value;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                null,
                '/streams/{webId}/value'
            );

            return [null, $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation streamUpdateValues
     *
     * Updates multiple values for the specified stream.
     *
     * @param string $web_id The ID of the stream. (required)
     * @param \PIWebAPI\Client\Model\TimedValue[] $values The values to add or update. (required)
     * @param string $buffer_option The desired AFBufferOption. The default is &#39;BufferIfPossible&#39;. (optional)
     * @param string $update_option The desired AFUpdateOption. The default is &#39;Replace&#39;. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return \PIWebAPI\Client\Model\ItemsSubstatus
     */
    public function streamUpdateValues($web_id, $values, $buffer_option = null, $update_option = null)
    {
        list($response) = $this->streamUpdateValuesWithHttpInfo($web_id, $values, $buffer_option, $update_option);
        return $response;
    }

    /**
     * Operation streamUpdateValuesWithHttpInfo
     *
     * Updates multiple values for the specified stream.
     *
     * @param string $web_id The ID of the stream. (required)
     * @param \PIWebAPI\Client\Model\TimedValue[] $values The values to add or update. (required)
     * @param string $buffer_option The desired AFBufferOption. The default is &#39;BufferIfPossible&#39;. (optional)
     * @param string $update_option The desired AFUpdateOption. The default is &#39;Replace&#39;. (optional)
     * @throws \PIWebAPI\Client\ApiException on non-2xx response
     * @return array of \PIWebAPI\Client\Model\ItemsSubstatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function streamUpdateValuesWithHttpInfo($web_id, $values, $buffer_option = null, $update_option = null)
    {
        // verify the required parameter 'web_id' is set
        if ($web_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $web_id when calling streamUpdateValues');
        }
        // verify the required parameter 'values' is set
        if ($values === null) {
            throw new \InvalidArgumentException('Missing the required parameter $values when calling streamUpdateValues');
        }
        // parse inputs
        $resourcePath = "/streams/{webId}/recorded";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json', 'text/json', 'text/html', 'application/x-ms-application']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json', 'text/json']);

        // query params
        if ($buffer_option !== null) {
            $queryParams['bufferOption'] = $this->apiClient->getSerializer()->toQueryValue($buffer_option);
        }
        // query params
        if ($update_option !== null) {
            $queryParams['updateOption'] = $this->apiClient->getSerializer()->toQueryValue($update_option);
        }
        // path params
        if ($web_id !== null) {
            $resourcePath = str_replace(
                "{" . "webId" . "}",
                $this->apiClient->getSerializer()->toPathValue($web_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($values)) {
            $_tempBody = $values;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                '\PIWebAPI\Client\Model\ItemsSubstatus',
                '/streams/{webId}/recorded'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\PIWebAPI\Client\Model\ItemsSubstatus', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsSubstatus', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 207:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\ItemsSubstatus', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\PIWebAPI\Client\Model\Errors', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }
}
