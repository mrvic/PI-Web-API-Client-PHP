<?php
/**
 * Response
 *
 * PHP version 5
 *
 * @category Class
 * @package  PIWebAPI\Client
 * @author   Swaagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * PI Web API 2017 Swagger Spec
 *
 * Swagger Spec file that describes PI Web API
 *
 * OpenAPI spec version: 1.9.0.235
 * Contact: techsupport@osisoft.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace PIWebAPI\Client\Model;

use \ArrayAccess;

/**
 * Response Class Doc Comment
 *
 * @category    Class */
/**
 * @package     PIWebAPI\Client
 * @author      Swagger Codegen team
 * @link        https://github.com/swagger-api/swagger-codegen
 */
class Response implements ArrayAccess
{
    /**
      * The original name of the model.
      * @var string
      */
    protected static $swaggerModelName = 'Response';

    /**
      * Array of property to type mappings. Used for (de)serialization
      * @var string[]
      */
    protected static $swaggerTypes = [
        'status' => 'int',
        'headers' => 'map[string,string]',
        'content' => 'object'
    ];

    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of attributes where the key is the local name, and the value is the original name
     * @var string[]
     */
    protected static $attributeMap = [
        'status' => 'Status',
        'headers' => 'Headers',
        'content' => 'Content'
    ];


    /**
     * Array of attributes to setter functions (for deserialization of responses)
     * @var string[]
     */
    protected static $setters = [
        'status' => 'setStatus',
        'headers' => 'setHeaders',
        'content' => 'setContent'
    ];


    /**
     * Array of attributes to getter functions (for serialization of requests)
     * @var string[]
     */
    protected static $getters = [
        'status' => 'getStatus',
        'headers' => 'getHeaders',
        'content' => 'getContent'
    ];

    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    public static function setters()
    {
        return self::$setters;
    }

    public static function getters()
    {
        return self::$getters;
    }

    const STATUS_100 = 100;
    const STATUS_101 = 101;
    const STATUS_200 = 200;
    const STATUS_201 = 201;
    const STATUS_202 = 202;
    const STATUS_203 = 203;
    const STATUS_204 = 204;
    const STATUS_205 = 205;
    const STATUS_206 = 206;
    const STATUS_300 = 300;
    const STATUS_301 = 301;
    const STATUS_302 = 302;
    const STATUS_303 = 303;
    const STATUS_304 = 304;
    const STATUS_305 = 305;
    const STATUS_306 = 306;
    const STATUS_307 = 307;
    const STATUS_400 = 400;
    const STATUS_401 = 401;
    const STATUS_402 = 402;
    const STATUS_403 = 403;
    const STATUS_404 = 404;
    const STATUS_405 = 405;
    const STATUS_406 = 406;
    const STATUS_407 = 407;
    const STATUS_408 = 408;
    const STATUS_409 = 409;
    const STATUS_410 = 410;
    const STATUS_411 = 411;
    const STATUS_412 = 412;
    const STATUS_413 = 413;
    const STATUS_414 = 414;
    const STATUS_415 = 415;
    const STATUS_416 = 416;
    const STATUS_417 = 417;
    const STATUS_426 = 426;
    const STATUS_500 = 500;
    const STATUS_501 = 501;
    const STATUS_502 = 502;
    const STATUS_503 = 503;
    const STATUS_504 = 504;
    const STATUS_505 = 505;
    

    
    /**
     * Gets allowable values of the enum
     * @return string[]
     */
    public function getStatusAllowableValues()
    {
        return [
            self::STATUS_100,
            self::STATUS_101,
            self::STATUS_200,
            self::STATUS_201,
            self::STATUS_202,
            self::STATUS_203,
            self::STATUS_204,
            self::STATUS_205,
            self::STATUS_206,
            self::STATUS_300,
            self::STATUS_301,
            self::STATUS_302,
            self::STATUS_303,
            self::STATUS_304,
            self::STATUS_305,
            self::STATUS_306,
            self::STATUS_307,
            self::STATUS_400,
            self::STATUS_401,
            self::STATUS_402,
            self::STATUS_403,
            self::STATUS_404,
            self::STATUS_405,
            self::STATUS_406,
            self::STATUS_407,
            self::STATUS_408,
            self::STATUS_409,
            self::STATUS_410,
            self::STATUS_411,
            self::STATUS_412,
            self::STATUS_413,
            self::STATUS_414,
            self::STATUS_415,
            self::STATUS_416,
            self::STATUS_417,
            self::STATUS_426,
            self::STATUS_500,
            self::STATUS_501,
            self::STATUS_502,
            self::STATUS_503,
            self::STATUS_504,
            self::STATUS_505,
        ];
    }
    

    /**
     * Associative array for storing property values
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     * @param mixed[] $data Associated array of property values initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['status'] = isset($data['status']) ? $data['status'] : null;
        $this->container['headers'] = isset($data['headers']) ? $data['headers'] : null;
        $this->container['content'] = isset($data['content']) ? $data['content'] : null;
    }

    /**
     * show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalid_properties = [];
        $allowed_values = ["100", "101", "200", "201", "202", "203", "204", "205", "206", "300", "301", "302", "303", "304", "305", "306", "307", "400", "401", "402", "403", "404", "405", "406", "407", "408", "409", "410", "411", "412", "413", "414", "415", "416", "417", "426", "500", "501", "502", "503", "504", "505"];
        if (!in_array($this->container['status'], $allowed_values)) {
            $invalid_properties[] = "invalid value for 'status', must be one of #{allowed_values}.";
        }

        return $invalid_properties;
    }

    /**
     * validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properteis are valid
     */
    public function valid()
    {
        $allowed_values = ["100", "101", "200", "201", "202", "203", "204", "205", "206", "300", "301", "302", "303", "304", "305", "306", "307", "400", "401", "402", "403", "404", "405", "406", "407", "408", "409", "410", "411", "412", "413", "414", "415", "416", "417", "426", "500", "501", "502", "503", "504", "505"];
        if (!in_array($this->container['status'], $allowed_values)) {
            return false;
        }
        return true;
    }


    /**
     * Gets status
     * @return int
     */
    public function getStatus()
    {
        return $this->container['status'];
    }

    /**
     * Sets status
     * @param int $status
     * @return $this
     */
    public function setStatus($status)
    {
        $allowed_values = array('100', '101', '200', '201', '202', '203', '204', '205', '206', '300', '301', '302', '303', '304', '305', '306', '307', '400', '401', '402', '403', '404', '405', '406', '407', '408', '409', '410', '411', '412', '413', '414', '415', '416', '417', '426', '500', '501', '502', '503', '504', '505');
        if (!is_null($status) && (!in_array($status, $allowed_values))) {
            throw new \InvalidArgumentException("Invalid value for 'status', must be one of '100', '101', '200', '201', '202', '203', '204', '205', '206', '300', '301', '302', '303', '304', '305', '306', '307', '400', '401', '402', '403', '404', '405', '406', '407', '408', '409', '410', '411', '412', '413', '414', '415', '416', '417', '426', '500', '501', '502', '503', '504', '505'");
        }
        $this->container['status'] = $status;

        return $this;
    }

    /**
     * Gets headers
     * @return map[string,string]
     */
    public function getHeaders()
    {
        return $this->container['headers'];
    }

    /**
     * Sets headers
     * @param map[string,string] $headers
     * @return $this
     */
    public function setHeaders($headers)
    {
        $this->container['headers'] = $headers;

        return $this;
    }

    /**
     * Gets content
     * @return object
     */
    public function getContent()
    {
        return $this->container['content'];
    }

    /**
     * Sets content
     * @param object $content
     * @return $this
     */
    public function setContent($content)
    {
        $this->container['content'] = $content;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     * @param  integer $offset Offset
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     * @param  integer $offset Offset
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     * @param  integer $offset Offset
     * @param  mixed   $value  Value to be set
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     * @param  integer $offset Offset
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(\PIWebAPI\Client\ObjectSerializer::sanitizeForSerialization($this), JSON_PRETTY_PRINT);
        }

        return json_encode(\PIWebAPI\Client\ObjectSerializer::sanitizeForSerialization($this));
    }
}

